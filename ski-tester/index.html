<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Ski Pressure Testing System | Denys Shlyakhtovskyy</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <link rel="stylesheet" href="/style.css" />

  <style>
    body{
      background: #ffffff;
      color: #000;
    }

    .stats-table{
      width: 100%;
      max-width: 70ch;
      margin: 0 auto;
      border-collapse: collapse;
      text-align: left;
    }
    .stats-table th,
    .stats-table td{
      padding: 10px 12px;
      border-bottom: 1px solid rgba(255,255,255,0.12);
      vertical-align: top;
    }
    .stats-table th{
      width: 42%;
      font-weight: 600;
      opacity: 0.9;
    }
    .stats-table td{
      opacity: 0.95;
    }

    .schematics-list{
      text-align: center;
      margin-top: 8px;
    }
    .schematics-list .section-link{
      display: block;
      width: 100%;
      margin: 14px 0 8px 0;
    }
    .schematics-list .drop-panel{
      text-align: center;
      margin: 0 auto 8px auto;
      max-width: 70ch;
    }
    .schematics-list .drop-panel img{
      margin: 0 auto;
    }
    .schematics-list .drop-panel p{
      text-align: center;
      margin-top: 10px;
    }

    .top-link{
      display: block;
      width: fit-content;
      margin: 14px 0 8px 0;
    }

    .stl-viewer{
      width: 100%;
      max-width: 1200px;
      margin: 14px auto 0;
      position: relative;
      height: 520px;
    }

    .rotate-hint{
      position: absolute;
      top: 10px;
      left: 10px;
      padding: 8px 10px;
      border-radius: 10px;
      background: rgba(255,255,255,0.88);
      border: 1px solid rgba(0,0,0,0.12);
      backdrop-filter: blur(6px);
      font: inherit;
      font-weight: 500;
      pointer-events: none;
      z-index: 2;
    }

    .stl-viewer canvas{
      display: block;
      width: 100%;
      height: 100%;
    }
  </style>
</head>

<body>
  <div class="container">
    <a class="back" href="/projects/">← Back to Projects</a>
    <h1>Ski Pressure Testing System</h1>

    <p></p>
    <hr />

    <section class="drop" data-drop>
      <a class="section-link top-link" href="#" data-drop-btn>3D Model</a>

      <div class="drop-panel" hidden aria-hidden="true" data-drop-panel>
        <div class="drop-inner">
          <div class="stl-viewer" data-stl-viewer data-stl="/assets/stl/beam.stl">
            <div class="rotate-hint" aria-hidden="true" title="Drag to rotate">⟳ Drag</div>
          </div>

          <p>
            This project is currently in progress, so related media and documentation are limited at this time as the system is still being developed, tested, and refined.
          </p>

          <h3>Technical Overview</h3>
          <hr />

          <p>
            The ski pressure testing system uses distributed load-cell sensing to measure force distribution along a mounted ski. Each sensing module consists of a load cell connected to an HX711 analog-to-digital converter (ADC). Eight HX711 ADCs are connected to a single Arduino Nano, and a total of fifteen Arduino Nano boards are used to collect load-cell measurements across the system.
          </p>

          <p>
            A separate Arduino is dedicated to actuator control, managing the extension of a linear actuator used to apply controlled force to the ski. All microcontrollers are connected to a laptop through a powered USB hub. The laptop software aggregates weight readings from the sensor network, generates a pressure-distribution graph of the ski, and monitors the applied force in real time during actuator extension to ensure the desired load is applied.
          </p>
        </div>
      </div>
    </section>

    <!--<section class="drop" data-drop>
      <a class="section-link top-link" href="#" data-drop-btn>Interactive System Architecture</a>
      <div class="drop-panel" hidden aria-hidden="true" data-drop-panel>
        <div class="drop-inner">
          <div class="schematics-list"></div>
        </div>
      </div>
    </section>

    <section class="drop" data-drop>
      <a class="section-link top-link" href="#" data-drop-btn>Hardware Implementation</a>
      <div class="drop-panel" hidden aria-hidden="true" data-drop-panel>
        <div class="drop-inner"></div>
      </div>
    </section>

    <section class="drop" data-drop>
      <a class="section-link top-link" href="#" data-drop-btn>Control</a>
      <div class="drop-panel" hidden aria-hidden="true" data-drop-panel>
        <div class="drop-inner"></div>
      </div>
    </section>

    <section class="drop" data-drop>
      <a class="section-link top-link" href="#" data-drop-btn>Skills and Outcomes</a>
      <div class="drop-panel" hidden aria-hidden="true" data-drop-panel>
        <div class="drop-inner"></div>
      </div>
    </section>-->

    <script>
      function shiftToViewportCenter(el){
        const r = el.getBoundingClientRect();
        const elCenter = r.left + r.width / 2;
        const viewportCenter = window.innerWidth / 2;
        return viewportCenter - elCenter;
      }

      function waitForTransition(el, prop){
        return new Promise((resolve) => {
          const onEnd = (e) => {
            if (e.propertyName !== prop) return;
            el.removeEventListener("transitionend", onEnd);
            resolve();
          };
          el.addEventListener("transitionend", onEnd);
        });
      }

      async function openPanel(panel){
        panel.hidden = false;
        panel.setAttribute("aria-hidden", "false");
        panel.style.maxHeight = "0px";
        panel.getBoundingClientRect();
        panel.classList.add("is-open");
        panel.style.maxHeight = panel.scrollHeight + "px";
        await waitForTransition(panel, "max-height");
        panel.style.maxHeight = "none";
      }

      async function closePanel(panel){
        panel.style.maxHeight = panel.scrollHeight + "px";
        panel.getBoundingClientRect();
        panel.classList.remove("is-open");
        panel.style.maxHeight = "0px";
        await waitForTransition(panel, "max-height");
        panel.hidden = true;
        panel.setAttribute("aria-hidden", "true");
      }

      function hardCloseInside(root){
        root.querySelectorAll(".drop-panel").forEach((p) => {
          p.classList.remove("is-open");
          p.style.maxHeight = "0px";
          p.hidden = true;
          p.setAttribute("aria-hidden", "true");
        });
        root.querySelectorAll(".section-link").forEach((a) => a.classList.remove("is-selected"));
      }

      document.querySelectorAll("[data-drop]").forEach((drop) => {
        const topBtn = drop.querySelector("[data-drop-btn]");
        const topPanel = drop.querySelector("[data-drop-panel]");
        if (!topBtn || !topPanel) return;

        let open = false;
        let sliding = false;

        async function slideToCenter(){
          if (sliding) return;
          sliding = true;

          topBtn.style.transform = "translateX(0px)";
          topBtn.getBoundingClientRect();

          requestAnimationFrame(() => {
            const shift = shiftToViewportCenter(topBtn);
            topBtn.style.transform = `translateX(${shift}px)`;
          });

          await waitForTransition(topBtn, "transform");
          sliding = false;
        }

        async function slideBackLeft(){
          if (sliding) return;
          sliding = true;

          topBtn.style.transform = "translateX(0px)";
          await waitForTransition(topBtn, "transform");
          sliding = false;
        }

        topBtn.addEventListener("click", async (e) => {
          e.preventDefault();
          if (sliding) return;

          open = !open;

          if (open){
            topBtn.classList.add("is-selected");
            await slideToCenter();
            await openPanel(topPanel);
          } else {
            hardCloseInside(topPanel);
            await closePanel(topPanel);
            topBtn.classList.remove("is-selected");
            await slideBackLeft();
          }
        });

        window.addEventListener("resize", () => {
          if (open){
            topBtn.style.transform = `translateX(${shiftToViewportCenter(topBtn)}px)`;
            if (!topPanel.hidden && topPanel.style.maxHeight !== "none"){
              topPanel.style.maxHeight = topPanel.scrollHeight + "px";
            }
          }
        });
      });
    </script>

    <script type="module">
      import * as THREE from "https://unpkg.com/three@0.161.0/build/three.module.js";
      import { OrbitControls } from "https://unpkg.com/three@0.161.0/examples/jsm/controls/OrbitControls.js";
      import { STLLoader } from "https://unpkg.com/three@0.161.0/examples/jsm/loaders/STLLoader.js";

      function initSTLViewer(container){
        if (container.dataset.viewerInited === "1") return;
        container.dataset.viewerInited = "1";

        const hint = container.querySelector(".rotate-hint");
        const stlPath = container.getAttribute("data-stl") || "/assets/stl/beam.stl";

        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0xfafafa);

        const camera = new THREE.PerspectiveCamera(45, 1, 0.1, 10000);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setPixelRatio(window.devicePixelRatio);
        container.appendChild(renderer.domElement);

        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enablePan = false;
        controls.enableDamping = true;
        controls.dampingFactor = 0.08;
        controls.minPolarAngle = 0;
        controls.maxPolarAngle = Math.PI;
        controls.minAzimuthAngle = -Infinity;
        controls.maxAzimuthAngle = Infinity;

        renderer.domElement.addEventListener("pointerdown", () => { if (hint) hint.style.display = "none"; }, { once: true });
        renderer.domElement.addEventListener("wheel", () => { if (hint) hint.style.display = "none"; }, { once: true });

        const ambient = new THREE.AmbientLight(0xffffff, 0.75);
        scene.add(ambient);

        const dir = new THREE.DirectionalLight(0xffffff, 0.9);
        dir.position.set(120, -120, 240);
        scene.add(dir);

        const material = new THREE.MeshStandardMaterial({
          color: 0xcfcfcf,
          metalness: 0.15,
          roughness: 0.55
        });

        const loader = new STLLoader();

        function measure(){
          const r = container.getBoundingClientRect();
          const w = Math.max(1, Math.round(r.width));
          const h = Math.max(1, Math.round(r.height));
          return { w, h };
        }

        function resize(){
          const { w, h } = measure();
          camera.aspect = w / h;
          camera.updateProjectionMatrix();
          renderer.setSize(w, h, false);
        }

        function fitCameraToObject(obj){
          const box = new THREE.Box3().setFromObject(obj);
          const size = box.getSize(new THREE.Vector3());
          const center = box.getCenter(new THREE.Vector3());

          const maxDim = Math.max(size.x, size.y, size.z);
          const fov = camera.fov * (Math.PI / 180);
          let dist = (maxDim / 2) / Math.tan(fov / 2);
          dist *= 1.8;

          camera.position.set(center.x, center.y, center.z + dist);
          camera.near = Math.max(0.1, dist / 200);
          camera.far = Math.max(10000, dist * 20);
          camera.updateProjectionMatrix();

          controls.target.copy(center);
          controls.minDistance = Math.max(20, maxDim * 0.35);
          controls.maxDistance = Math.max(2000, maxDim * 12);
          controls.update();
        }

        let mesh = null;

        loader.load(stlPath, (geometry) => {
          geometry.computeVertexNormals();
          mesh = new THREE.Mesh(geometry, material);
          scene.add(mesh);

          const box0 = new THREE.Box3().setFromObject(mesh);
          const center0 = box0.getCenter(new THREE.Vector3());
          mesh.position.sub(center0);

          mesh.rotation.y += Math.PI / 2;

          resize();
          fitCameraToObject(mesh);
        });

        function animate(){
          requestAnimationFrame(animate);
          controls.update();
          renderer.render(scene, camera);
        }
        animate();

        window.addEventListener("resize", () => {
          resize();
          if (mesh) fitCameraToObject(mesh);
        });

        const panel = container.closest("[data-drop-panel]");
        if (panel){
          const mo = new MutationObserver(() => {
            if (!panel.hidden){
              requestAnimationFrame(() => {
                resize();
                if (mesh) fitCameraToObject(mesh);
              });
            }
          });
          mo.observe(panel, { attributes: true, attributeFilter: ["hidden", "style", "class", "aria-hidden"] });
        }

        resize();
      }

      function whenVisibleThenInit(container){
        const panel = container.closest("[data-drop-panel]");
        const tryInit = () => {
          const r = container.getBoundingClientRect();
          if (r.width > 2 && r.height > 2) initSTLViewer(container);
        };

        if (!panel || !panel.hidden){
          requestAnimationFrame(tryInit);
          return;
        }

        const mo = new MutationObserver(() => {
          if (!panel.hidden){
            requestAnimationFrame(() => {
              tryInit();
            });
          }
        });

        mo.observe(panel, { attributes: true, attributeFilter: ["hidden", "style", "class", "aria-hidden"] });
      }

      document.querySelectorAll("[data-stl-viewer]").forEach((el) => {
        whenVisibleThenInit(el);
      });
    </script>
  </div>
</body>
</html>
