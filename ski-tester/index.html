<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Ski Pressure Testing System | Denys Shlyakhtovskyy</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <link rel="stylesheet" href="/style.css">

  <style>
    body{
      background: #ffffff;
      color: #000;
    }

    .stats-table{
      width: 100%;
      max-width: 70ch;
      margin: 0 auto;
      border-collapse: collapse;
      text-align: left;
    }
    .stats-table th,
    .stats-table td{
      padding: 10px 12px;
      border-bottom: 1px solid rgba(255,255,255,0.12);
      vertical-align: top;
    }
    .stats-table th{
      width: 42%;
      font-weight: 600;
      opacity: 0.9;
    }
    .stats-table td{
      opacity: 0.95;
    }

    .schematics-list{
      text-align: center;
      margin-top: 8px;
    }
    .schematics-list .section-link{
      display: block;
      width: 100%;
      margin: 14px 0 8px 0;
    }
    .schematics-list .drop-panel{
      text-align: center;
      margin: 0 auto 8px auto;
      max-width: 70ch;
    }
    .schematics-list .drop-panel img{
      margin: 0 auto;
    }
    .schematics-list .drop-panel p{
      text-align: center;
      margin-top: 10px;
    }

    .top-link{
      display: block;
      width: fit-content;
      margin: 14px 0 8px 0;
    }

    .map-wrap{
      position: relative;
      width: 100%;
      max-width: 900px;
      margin: 18px auto 10px;
    }
    .map-wrap img{
      width: 100%;
      height: auto;
      display: block;
      border-radius: 10px;
    }
    .map-overlay{
      position: absolute;
      inset: 0;
      width: 100%;
      height: 100%;
    }

    .hot{
      fill: rgba(0,0,0,0);
      stroke: rgba(0,0,0,0);
      stroke-width: 3;
      cursor: pointer;
      transition: fill 180ms ease, stroke 180ms ease;
    }
    .hot:hover{ stroke: rgba(0,0,0,0.18); }
    .hot.is-active{ stroke: rgba(0,0,0,0.25); }

    .hot-red:hover, .hot-red.is-active{
      fill: rgba(255, 0, 0, 0.14);
      stroke: rgba(255, 0, 0, 0.55);
    }
    .hot-blue:hover, .hot-blue.is-active{
      fill: rgba(0, 90, 255, 0.14);
      stroke: rgba(0, 90, 255, 0.55);
    }
    .hot-cyan:hover, .hot-cyan.is-active{
      fill: rgba(0, 200, 220, 0.14);
      stroke: rgba(0, 200, 220, 0.55);
    }
    .hot-black:hover, .hot-black.is-active{
      fill: rgba(0, 0, 0, 0.10);
      stroke: rgba(0, 0, 0, 0.55);
    }
    .hot-magenta:hover, .hot-magenta.is-active{
      fill: rgba(255, 0, 255, 0.12);
      stroke: rgba(255, 0, 255, 0.55);
    }
    .hot-gray:hover, .hot-gray.is-active{
      fill: rgba(120, 120, 120, 0.18);
      stroke: rgba(120, 120, 120, 0.70);
    }

    .map-panels{
      max-width: 900px;
      margin: 0 auto;
    }
    .map-panels h3{
      margin: 12px 0 6px;
    }

    .zoom-wrap{
      position: relative;
      width: 100%;
      max-width: 900px;
      margin: 0 auto;
    }
    .zoom-img{
      width: 100%;
      height: auto;
      display: block;
      border-radius: 10px;
    }
    .zoom-lens{
      position: absolute;
      left: 0;
      top: 0;
      width: 220px;
      height: 220px;
      border: 2px solid #000;
      border-radius: 14px;
      background-repeat: no-repeat;
      background-color: #fff;
      pointer-events: none;
      opacity: 0;
      transform: translate(-9999px, -9999px);
      transition: opacity 120ms ease;
    }
    .zoom-wrap:hover .zoom-lens{
      opacity: 1;
    }

    .hw-grid{
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(260px, 1fr));
      gap: 18px;
      max-width: 900px;
      margin: 0 auto;
    }
    .hw-card{
      background: transparent;
    }
    .hw-card .zoom-img{
      width: 100%;
      height: 420px;
      object-fit: cover;
      background: none;
      border-radius: 10px;
    }
    .hw-card .zoom-lens{
      border-radius: 10px;
    }
    .hw-cap{
      margin-top: 10px;
      text-align: center;
      font-weight: 500;
    }
    .zoom-lens{
      border-radius: 0;
    }
    .hw-cap{
      margin-top: 10px;
      text-align: center;
      font-weight: 500;
    }

    .stl-viewer{
      width: 100%;
      max-width: 1200px;
      margin: 14px auto 0;
      position: relative;
    }
    .stl-canvas{
      width: 100%;
      height: 520px;
      display: block;
      background: #ffffff;
      border: none;
      border-radius: 0;
    }
    .stl-hint{
      position: absolute;
      top: 10px;
      left: 10px;
      padding: 8px 10px;
      border-radius: 10px;
      background: rgba(255,255,255,0.88);
      border: 1px solid rgba(0,0,0,0.12);
      backdrop-filter: blur(6px);
      font: inherit;
      font-weight: 500;
      opacity: 0;
      transform: translateY(-4px);
      transition: opacity 240ms ease, transform 240ms ease;
      pointer-events: none;
    }
    .stl-hint.is-show{
      opacity: 1;
      transform: translateY(0);
    }
  </style>

  <script type="importmap">
{
  "imports": {
    "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
    "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
  }
}
  </script>
</head>

<body>
  <div class="container">
    <a class="back" href="/projects/">← Back to Projects</a>
    <h1>Ski Pressure Testing System</h1>

    <p></p>

    <hr>

    <section class="drop" data-drop>
      <a class="section-link top-link" href="#" data-drop-btn>3D Model</a>

      <div class="drop-panel" hidden aria-hidden="true" data-drop-panel>
        <div class="drop-inner">
  <div class="stl-viewer" data-stl-viewer style="width: 100%; height: 520px;">
    <div class="rotate-hint" aria-hidden="true" title="Drag to rotate">⟳ Drag</div>

</div>
        </div>
        <p>
This project is currently in progress, so related media and documentation are limited at this time as the system is still being developed, tested, and refined.
</p>

<h3>Technical Overview</h3>
<hr>

<p>
The ski pressure testing system uses distributed load-cell sensing to measure force distribution along a mounted ski. Each sensing module consists of a load cell connected to an HX711 analog-to-digital converter (ADC). Eight HX711 ADCs are connected to a single Arduino Nano, and a total of fifteen Arduino Nano boards are used to collect load-cell measurements across the system.
</p>

<p>
A separate Arduino is dedicated to actuator control, managing the extension of a linear actuator used to apply controlled force to the ski. All microcontrollers are connected to a laptop through a powered USB hub. The laptop software aggregates weight readings from the sensor network, generates a pressure-distribution graph of the ski, and monitors the applied force in real time during actuator extension to ensure the desired load is applied.
</p>

      </div>
    </section>

    <!--<section class="drop" data-drop>
      <a class="section-link top-link" href="#" data-drop-btn>Interactive System Architecture</a>

      <div class="drop-panel" hidden aria-hidden="true" data-drop-panel>
        <div class="drop-inner">
          <div class="schematics-list">
          </div>
        </div>
      </div>
    </section>

    <section class="drop" data-drop>
      <a class="section-link top-link" href="#" data-drop-btn>Hardware Implementation</a>

      <div class="drop-panel" hidden aria-hidden="true" data-drop-panel>
        <div class="drop-inner">
        </div>
      </div>
    </section>

    <section class="drop" data-drop>
      <a class="section-link top-link" href="#" data-drop-btn>Control</a>

      <div class="drop-panel" hidden aria-hidden="true" data-drop-panel>
        <div class="drop-inner">
        </div>
      </div>
    </section>

    <section class="drop" data-drop>
      <a class="section-link top-link" href="#" data-drop-btn>Skills and Outcomes</a>

      <div class="drop-panel" hidden aria-hidden="true" data-drop-panel>
        <div class="drop-inner">
        </div>
      </div>
    </section>-->

    <script>
      function shiftToViewportCenter(el){
        const r = el.getBoundingClientRect();
        const elCenter = r.left + r.width / 2;
        const viewportCenter = window.innerWidth / 2;
        return viewportCenter - elCenter;
      }

      function waitForTransition(el, prop){
        return new Promise((resolve) => {
          const onEnd = (e) => {
            if (e.propertyName !== prop) return;
            el.removeEventListener("transitionend", onEnd);
            resolve();
          };
          el.addEventListener("transitionend", onEnd);
        });
      }

      async function openPanel(panel){
        panel.hidden = false;
        panel.setAttribute("aria-hidden", "false");
        panel.style.maxHeight = "0px";
        panel.getBoundingClientRect();
        panel.classList.add("is-open");
        panel.style.maxHeight = panel.scrollHeight + "px";
        await waitForTransition(panel, "max-height");
        panel.style.maxHeight = "none";
      }

      async function closePanel(panel){
        panel.style.maxHeight = panel.scrollHeight + "px";
        panel.getBoundingClientRect();
        panel.classList.remove("is-open");
        panel.style.maxHeight = "0px";
        await waitForTransition(panel, "max-height");
        panel.hidden = true;
        panel.setAttribute("aria-hidden", "true");
      }

      function hardCloseInside(root){
        root.querySelectorAll(".drop-panel").forEach((p) => {
          p.classList.remove("is-open");
          p.style.maxHeight = "0px";
          p.hidden = true;
          p.setAttribute("aria-hidden", "true");
        });
        root.querySelectorAll(".section-link").forEach((a) => a.classList.remove("is-selected"));
      }

      document.querySelectorAll("[data-drop]").forEach((drop) => {
        const topBtn = drop.querySelector("[data-drop-btn]");
        const topPanel = drop.querySelector("[data-drop-panel]");
        if (!topBtn || !topPanel) return;

        let open = false;
        let sliding = false;

        async function slideToCenter(){
          if (sliding) return;
          sliding = true;

          topBtn.style.transform = "translateX(0px)";
          topBtn.getBoundingClientRect();

          requestAnimationFrame(() => {
            const shift = shiftToViewportCenter(topBtn);
            topBtn.style.transform = `translateX(${shift}px)`;
          });

          await waitForTransition(topBtn, "transform");
          sliding = false;
        }

        async function slideBackLeft(){
          if (sliding) return;
          sliding = true;

          topBtn.style.transform = "translateX(0px)";
          await waitForTransition(topBtn, "transform");

          sliding = false;
        }

        topBtn.addEventListener("click", async (e) => {
          e.preventDefault();
          if (sliding) return;

          open = !open;

          if (open){
            topBtn.classList.add("is-selected");
            await slideToCenter();
            await openPanel(topPanel);
          } else {
            hardCloseInside(topPanel);
            await closePanel(topPanel);
            topBtn.classList.remove("is-selected");
            await slideBackLeft();
          }
        });

        drop.querySelectorAll("[data-sub-btn]").forEach((btn) => {
          const key = btn.getAttribute("data-sub-btn");
          const panel = drop.querySelector(`[data-sub-panel="${key}"]`);
          if (!panel) return;

          btn.addEventListener("click", async (e) => {
            e.preventDefault();
            if (topPanel.hidden) return;

            if (panel.hidden){
              btn.classList.add("is-selected");
              await openPanel(panel);
            } else {
              await closePanel(panel);
              btn.classList.remove("is-selected");
            }
          });
        });

        window.addEventListener("resize", () => {
          if (open){
            topBtn.style.transform = `translateX(${shiftToViewportCenter(topBtn)}px)`;
            if (!topPanel.hidden && topPanel.style.maxHeight !== "none"){
              topPanel.style.maxHeight = topPanel.scrollHeight + "px";
            }
          }
        });
      });

      document.querySelectorAll(".subsystem-map").forEach((map) => {
        const regions = Array.from(map.querySelectorAll(".map-overlay .hot"));
        const panels = Array.from(map.querySelectorAll("[data-map-panel]"));
        const panelByKey = new Map(panels.map(p => [p.getAttribute("data-map-panel"), p]));

        let active = null;

        regions.forEach((r) => {
          r.addEventListener("click", async () => {
            const key = r.dataset.target;
            const panel = panelByKey.get(key);
            if (!panel) return;

            if (active === key){
              r.classList.remove("is-active");
              await closePanel(panel);
              active = null;
              return;
            }

            if (active){
              const prevRegion = regions.find(x => x.dataset.target === active);
              const prevPanel = panelByKey.get(active);
              if (prevRegion) prevRegion.classList.remove("is-active");
              if (prevPanel && !prevPanel.hidden) await closePanel(prevPanel);
            }

            regions.forEach(x => x.classList.toggle("is-active", x.dataset.target === key));
            await openPanel(panel);
            active = key;

            panel.scrollIntoView({ behavior: "smooth", block: "start" });
          });
        });
      });

      (function setupLensZoom(){
        document.querySelectorAll(".zoom-wrap").forEach((wrap) => {
          const img = wrap.querySelector(".zoom-img");
          const lens = wrap.querySelector(".zoom-lens");
          if (!img || !lens) return;

          function getNum(attr, fallback){
            const v = Number(wrap.dataset[attr]);
            return Number.isFinite(v) ? v : fallback;
          }

          function syncLensSize(){
            const s = getNum("lens", 220);
            lens.style.width = s + "px";
            lens.style.height = s + "px";
            return s;
          }

          function updateBackground(){
            const r = img.getBoundingClientRect();
            const zoom = getNum("zoom", 2.0);

            lens.style.backgroundImage = `url(${img.src})`;
            lens.style.backgroundSize = `${r.width * zoom}px ${r.height * zoom}px`;
            return { r, zoom };
          }

          function setPos(e){
            const { r, zoom } = updateBackground();
            const lensSize = syncLensSize();
            const half = lensSize / 2;

            let x = e.clientX - r.left;
            let y = e.clientY - r.top;

            x = Math.max(0, Math.min(x, r.width));
            y = Math.max(0, Math.min(y, r.height));

            const lx = x - half;
            const ly = y - half;

            lens.style.transform = `translate(${lx}px, ${ly}px)`;

            const bx = -x * zoom + half;
            const by = -y * zoom + half;
            lens.style.backgroundPosition = `${bx}px ${by}px`;
          }

          function onEnter(){
            syncLensSize();
            updateBackground();
            lens.style.opacity = "1";
          }

          function onLeave(){
            lens.style.opacity = "0";
            lens.style.transform = "translate(-9999px, -9999px)";
          }

          wrap.addEventListener("mouseenter", onEnter);
          wrap.addEventListener("mousemove", setPos);
          wrap.addEventListener("mouseleave", onLeave);

          window.addEventListener("resize", () => {
            if (lens.style.opacity === "1") updateBackground();
          });
        });
      })();
    </script>
<script type="module">
  import * as THREE from "https://unpkg.com/three@0.161.0/build/three.module.js";
  import { OrbitControls } from "https://unpkg.com/three@0.161.0/examples/jsm/controls/OrbitControls.js";
  import { STLLoader } from "https://unpkg.com/three@0.161.0/examples/jsm/loaders/STLLoader.js";

  function initSTLViewer(container, stlPath){
    const hint = container.querySelector(".rotate-hint");
    const hideHint = () => { if (hint) hint.style.display = "none"; };

    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0xfafafa);

    const camera = new THREE.PerspectiveCamera(
      45,
      container.clientWidth / container.clientHeight,
      0.1,
      5000
    );
    camera.position.set(0, 0, 250);

    const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: false });
    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap;
    renderer.setSize(container.clientWidth, container.clientHeight);
    renderer.setPixelRatio(window.devicePixelRatio);
    container.appendChild(renderer.domElement);

    renderer.domElement.addEventListener("pointerdown", hideHint, { once: true });
    renderer.domElement.addEventListener("wheel", hideHint, { once: true });

    const ambient = new THREE.AmbientLight(0xffffff, 0.6);
    scene.add(ambient);

    const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
    dirLight.position.set(100, -100, 200);
    scene.add(dirLight);

    const camLight = new THREE.DirectionalLight(0xffffff, 1.2);
    camLight.castShadow = true;
    camLight.shadow.mapSize.set(2048, 2048);
    camLight.shadow.camera.near = 0.1;
    camLight.shadow.camera.far = 5000;
    camLight.shadow.camera.left = -300;
    camLight.shadow.camera.right = 300;
    camLight.shadow.camera.top = 300;
    camLight.shadow.camera.bottom = -300;
    camLight.shadow.bias = -0.0002;
    camLight.shadow.normalBias = 0.02;
    camLight.position.set(0, 0, 1);
    camLight.target.position.set(0, 0, 0);
    camera.add(camLight);
    camera.add(camLight.target);
    scene.add(camera);

    // Controls (NO rotation limits)
    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enablePan = false;
    controls.enableDamping = true;
    controls.dampingFactor = 0.08;

    // remove orbit limits
controls.minPolarAngle = 0.0001;
controls.maxPolarAngle = Math.PI - 0.0001;
    controls.minAzimuthAngle = -Infinity;
    controls.maxAzimuthAngle = Infinity;

    controls.minDistance = 50;
    controls.maxDistance = 2000;

    const material = new THREE.MeshStandardMaterial({
      color: 0xcfcfcf,
      metalness: 0.15,
      roughness: 0.55
    });

    const loader = new STLLoader();

    // Rotate mesh in 90° steps so:
    //  - smallest dimension becomes Y (thickness = "up")
    //  - longest dimension becomes X (beam lays horizontally)
    function rotateToHorizontal(mesh){
      // current dims
      const box0 = new THREE.Box3().setFromObject(mesh);
      const size0 = box0.getSize(new THREE.Vector3());
      const dims = [size0.x, size0.y, size0.z];

      const idxMin = dims.indexOf(Math.min(...dims)); // thickness axis
      const idxMax = dims.indexOf(Math.max(...dims)); // length axis

      // Step 1: make thickness axis -> Y
      // map axis indices: 0=x,1=y,2=z
      if (idxMin === 0){
        // X -> Y : rotate around Z by -90deg
        mesh.rotation.z -= Math.PI / 2;
      } else if (idxMin === 2){
        // Z -> Y : rotate around X by +90deg
        mesh.rotation.x += Math.PI / 2;
      }

      // Step 2: recompute, then make length axis -> X (while keeping thickness ~Y)
      const box1 = new THREE.Box3().setFromObject(mesh);
      const size1 = box1.getSize(new THREE.Vector3());
      const dims1 = [size1.x, size1.y, size1.z];
      const idxMax2 = dims1.indexOf(Math.max(...dims1));

      if (idxMax2 === 1){
        // Y -> X : rotate around Z by +90deg
        mesh.rotation.z += Math.PI / 2;
      } else if (idxMax2 === 2){
        // Z -> X : rotate around Y by +90deg
        mesh.rotation.y += Math.PI / 2;
      }
    }

    loader.load(stlPath, (geometry) => {
      geometry.computeVertexNormals();

      const mesh = new THREE.Mesh(geometry, material);
      mesh.castShadow = true;
      mesh.receiveShadow = true;
      scene.add(mesh);

      // Orient beam "horizontal" before centering / camera fit
      rotateToHorizontal(mesh);

      // center the mesh
      const box = new THREE.Box3().setFromObject(mesh);
      const center = box.getCenter(new THREE.Vector3());
      mesh.position.sub(center);

      // fit camera to object
      const box2 = new THREE.Box3().setFromObject(mesh);
      const size = box2.getSize(new THREE.Vector3());
      const maxDim = Math.max(size.x, size.y, size.z);
      const dist = maxDim * 1.9;

camera.position.set(0, -dist, 0);   
controls.target.set(0, 0, 0);
camera.lookAt(0, 0, 0);
controls.update();
    });

    function animate(){
      requestAnimationFrame(animate);
      controls.update();
      renderer.render(scene, camera);
    }
    animate();

    const onResize = () => {
      const w = container.clientWidth;
      const h = container.clientHeight;
      if (!w || !h) return;
      camera.aspect = w / h;
      camera.updateProjectionMatrix();
      renderer.setSize(w, h);
    };
    window.addEventListener("resize", onResize);

    const panel = container.closest("[data-drop-panel]");
    if (panel){
      const mo = new MutationObserver(() => onResize());
      mo.observe(panel, { attributes: true, attributeFilter: ["hidden", "style", "class", "aria-hidden"] });
    }
  }

  document.querySelectorAll("[data-stl-viewer]").forEach((el) => {
    if (el.dataset.inited === "1") return;
    el.dataset.inited = "1";
    initSTLViewer(el, "/assets/stl/beam.stl");
  });
</script>


  </div>
</body>
</html>
