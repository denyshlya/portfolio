<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>FM Transceiver | Denys Shlyakhtovskyy</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <link rel="stylesheet" href="/style.css">

  <style>
    
    body{
      background: #ffffff;
      color: #000;
    }

    .stats-table{
    width: 100%;
    max-width: 70ch;
    margin: 0 auto;
    border-collapse: collapse;
    text-align: left;
  }
  .stats-table th,
  .stats-table td{
    padding: 10px 12px;
    border-bottom: 1px solid rgba(255,255,255,0.12);
    vertical-align: top;
  }
  .stats-table th{
    width: 42%;
    font-weight: 600;
    opacity: 0.9;
  }
  .stats-table td{
    opacity: 0.95;
  }
    .schematics-list{
      text-align: center;
      margin-top: 8px;
    }
    .schematics-list .section-link{
      display: block;
      width: 100%;
      margin: 14px 0 8px 0;
    }
    .schematics-list .drop-panel{
      text-align: center;
      margin: 0 auto 8px auto;
      max-width: 70ch;
    }
    .schematics-list .drop-panel img{
      margin: 0 auto;
    }
    .schematics-list .drop-panel p{
      text-align: center;
      margin-top: 10px;
    }

    /* stack top-level headers vertically (NO IDs) */
    .top-link{
      display: block;
      width: fit-content;
      margin: 14px 0 8px 0;
    }

    /* ===== subsystem map ===== */
    .map-wrap{
      position: relative;
      width: 100%;
      max-width: 900px;
      margin: 18px auto 10px;
    }
    .map-wrap img{
      width: 100%;
      height: auto;
      display: block;
      border-radius: 10px;
    }
    .map-overlay{
      position: absolute;
      inset: 0;
      width: 100%;
      height: 100%;
    }

    /* clickable regions: invisible until hover */
    .hot{
      fill: rgba(0,0,0,0);
      stroke: rgba(0,0,0,0);
      stroke-width: 3;
      cursor: pointer;
      transition: fill 180ms ease, stroke 180ms ease;
    }
    .hot:hover{ stroke: rgba(0,0,0,0.18); }
    .hot.is-active{ stroke: rgba(0,0,0,0.25); }

    .hot-red:hover, .hot-red.is-active{
      fill: rgba(255, 0, 0, 0.14);
      stroke: rgba(255, 0, 0, 0.55);
    }
    .hot-blue:hover, .hot-blue.is-active{
      fill: rgba(0, 90, 255, 0.14);
      stroke: rgba(0, 90, 255, 0.55);
    }
    .hot-cyan:hover, .hot-cyan.is-active{
      fill: rgba(0, 200, 220, 0.14);
      stroke: rgba(0, 200, 220, 0.55);
    }
    .hot-black:hover, .hot-black.is-active{
      fill: rgba(0, 0, 0, 0.10);
      stroke: rgba(0, 0, 0, 0.55);
    }
    .hot-audio:hover, .hot-audio.is-active{
      fill: rgba(120, 120, 120, 0.18);
      stroke: rgba(120, 120, 120, 0.70);
    }
    .hot-uc:hover, .hot-uc.is-active{
      fill: rgba(60, 60, 60, 0.22);
      stroke: rgba(60, 60, 60, 0.80);
    }
    .hot-magenta:hover, .hot-magenta.is-active{
      fill: rgba(255, 0, 255, 0.12);
      stroke: rgba(255, 0, 255, 0.55);
    }

    .map-panels{
      max-width: 900px;
      margin: 0 auto;
    }
    .map-panels h3{
      margin: 12px 0 6px;
    }

    /* ===== zoom ===== */
    .zoom-wrap{
      position: relative;
      width: 100%;
      max-width: 900px;
      margin: 0 auto;
    }

    .zoom-img{
      width: 100%;
      height: auto;
      display: block;
      border-radius: 10px;
    }

    .zoom-lens{
      position: absolute;
      left: 0;
      top: 0;
      width: 220px;              /* overridden by data-lens */
      height: 220px;
      border: 2px solid #000;
      border-radius: 14px;
      background-repeat: no-repeat;
      background-color: #fff;
      pointer-events: none;

      opacity: 0;
      transform: translate(-9999px, -9999px);
      transition: opacity 120ms ease;
    }

    .zoom-wrap:hover .zoom-lens{
      opacity: 1;
    }
    /* ===== hardware image grid ===== */

 .hw-grid{
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(260px, 1fr));
  gap: 18px;
  max-width: 900px;
  margin: 0 auto;
}

.hw-card{
  background: transparent;
}

.hw-card .zoom-img{
  width: 100%;
  height: 420px;
  object-fit: cover;
  background: none;
  border-radius: 10px;
}

/* lens should match the image style */
.hw-card .zoom-lens{
  border-radius: 10px;
}

.hw-cap{
  margin-top: 10px;
  text-align: center;
  font-weight: 500;
}

/* lens should also be square */
.zoom-lens{
  border-radius: 0;
}

.hw-cap{
  margin-top: 10px;
  text-align: center;
  font-weight: 500;
}
      .stl-viewer{
    width: 100%;
    max-width: 1200px;
    margin: 14px auto 0;
    position: relative;
  }
.stl-canvas{
  width: 100%;
  height: 520px;
  display: block;
  background: #ffffff;
  border: none;
  border-radius: 0;
}
.stl-hint{
  position: absolute;
  top: 10px;
  left: 10px;
  padding: 8px 10px;
  border-radius: 10px;
  background: rgba(255,255,255,0.88);
  border: 1px solid rgba(0,0,0,0.12);
  backdrop-filter: blur(6px);
  font: inherit;
  font-weight: 500;
  opacity: 0;
  transform: translateY(-4px);
  transition: opacity 240ms ease, transform 240ms ease;
  pointer-events: none;
}

.stl-hint.is-show{
  opacity: 1;
  transform: translateY(0);
}
  </style>
  <script type="importmap">
{
  "imports": {
    "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
    "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
  }
}
</script>

</head>

<body>
  <div class="container">
    <a class="back" href="/projects/">← Back to Projects</a>
    <h1>FM Transceiver</h1>

    <p>
      This project was made for the Electronics Engineering program at Okanagan College in 2022.
      The idea was to integrate digital control architecture with RF components to create a low power
      2-way FM radio (pair of walkie talkies); Below is a technical description of the project.
    </p>

    <hr>

    <!-- =========================
         TOP-LEVEL DROPDOWNS
         ========================= -->

    <!-- Quick Stats -->
    <section class="drop" data-drop>
      <a class="section-link top-link" href="#" data-drop-btn>Quick Stats</a>

      <div class="drop-panel" hidden aria-hidden="true" data-drop-panel>
        <div class="drop-inner">
          <div class="schematics-list">
              <table class="stats-table">
                <tbody>
                  <tr><th>Project</th><td>FM Transceiver Pair (two devices)</td></tr>
                  <tr><th>Program / Year</th><td>Electronic Engineering Technology, 2022 (Okanagan College)</td></tr>
                  <tr><th>Modulation</th><td>FM (Frequency Modulation)</td></tr>
                  <tr><th>Target Range</th><td>10 m (indoor short-range)</td></tr>
                  <tr><th>Battery</th><td>Single 18650 Li-ion (3000 mAh)</td></tr>
                  <tr><th>Standby Time (spec)</th><td>3 hours</td></tr>
                  <tr><th>Continuous TX Time (spec)</th><td>30 minutes</td></tr>
                  <tr><th>MCU</th><td>Microchip PIC24FJ1024GB606</td></tr>
                  <tr><th>RF Transceiver</th><td>Silicon Labs SI4720 (76–108 MHz band)</td></tr>
                  <tr><th>Audio Output</th><td>8 Ω speaker + TI TPA321 amplifier (BTL)</td></tr>
                  <tr><th>Display</th><td>1.3&quot; SPI GLCD (Adafruit 4313, 240×240, ST7789 controller)</td></tr>
                  <tr><th>Battery Protection</th><td>TI BQ77905 (“BATMAN”) + NTC + dual MOSFET cutoff</td></tr>
                  <tr><th>Battery Monitoring</th><td>MCP3021 (10-bit I²C ADC) + buffer stage</td></tr>
                  <tr><th>Status</th><td>Not fully functional (SPI timing/transfer issues prevented control of SI4720 + GLCD)</td></tr>
                </tbody>
            </table>
            
        

          </div>
        </div>
      </div>
    </section>

    <!-- Interactive System Architecture -->
    <section class="drop" data-drop>
      <a class="section-link top-link" href="#" data-drop-btn>Interactive System Architecture</a>

      <div class="drop-panel" hidden aria-hidden="true" data-drop-panel>
        <div class="drop-inner">
          <div class="schematics-list">
                <section class="subsystem-map">
                  <div class="map-wrap" aria-label="Subsystem diagram">
                    <img src="/assets/photos/fm/block-diagram.png" alt="FM Transceiver subsystem block diagram" />

                    <svg class="map-overlay" viewBox="0 0 872 804" aria-hidden="true">
                      <rect class="hot hot-red"     data-target="battery-management" x="77"  y="190" width="736" height="137" rx="18" />
                      <rect class="hot hot-blue"    data-target="interrupts"        x="260" y="17"  width="325" height="307" rx="18" />
                      <rect class="hot hot-cyan"    data-target="decoupling"        x="78"  y="330" width="195" height="142" rx="18" />
                      <rect class="hot hot-black"   data-target="glcd"             x="85"  y="490" width="465" height="120" rx="18" />
                      <rect class="hot hot-audio"   data-target="audio-amplifier"  x="325" y="355" width="225" height="120" rx="18" />
                      <rect class="hot hot-uc"      data-target="microcontroller"  x="340" y="632" width="210" height="120" rx="18" />
                      <rect class="hot hot-magenta" data-target="transceiver"      x="555" y="345" width="265" height="425" rx="18" />
                    </svg>
                  </div>

                  <!-- NOTE: These panels are now keyed by data-map-panel (NO IDs) -->
                  <div class="map-panels" data-map-panels>
                    <div class="drop-panel" hidden aria-hidden="true" data-map-panel="battery-management">
                      <div class="drop-inner">
                        <h3>Battery management</h3>
                        <p>The power supply block provides energy to the system and ensures safe battery operation. It includes the battery cell, a master disconnect switch for complete power isolation, and a battery management circuit that protects the cell and disconnects it under fault conditions.</p>
                      </div>
                    </div>

                    <div class="drop-panel" hidden aria-hidden="true" data-map-panel="interrupts">
                      <div class="drop-inner">
                        <h3>System inputs</h3>
                        <p>The system input block provides the primary user interface and power control for the device. It includes the microphone for audio input, user buttons for device control, and a main power switch that connects or disconnects the battery.</p>
                      </div>
                    </div>

                    <div class="drop-panel" hidden aria-hidden="true" data-map-panel="decoupling">
                      <div class="drop-inner">
                        <h3>MCU support</h3>
                        <p>The MCU support block contains the circuitry required for stable and reliable microcontroller operation. It includes decoupling capacitors that filter supply noise and stabilize the MCU power rails, as well as a crystal oscillator that provides the system clock.</p>
                      </div>
                    </div>

                    <div class="drop-panel" hidden aria-hidden="true" data-map-panel="glcd">
                      <div class="drop-inner">
                        <h3>Outputs</h3>
                        <p>The system output block includes the display and audio output components. A 1.3-inch screen presents key system information. Audio output is provided through a speaker driven by a dedicated amplifier.</p>
                      </div>
                    </div>

                    <div class="drop-panel" hidden aria-hidden="true" data-map-panel="audio-amplifier">
                      <div class="drop-inner">
                        <h3>Audio amplifier</h3>
                        <p>The audio amplifier block boosts the received audio signal to a level suitable for driving the speaker.</p>
                      </div>
                    </div>

                    <div class="drop-panel" hidden aria-hidden="true" data-map-panel="microcontroller">
                      <div class="drop-inner">
                        <h3>Microcontroller</h3>
                        <p>The MCU acts as the central controller for the system, handling user inputs, managing operating modes, and coordinating communication between the RF backend, display, and audio output.</p>
                      </div>
                    </div>

                    <div class="drop-panel" hidden aria-hidden="true" data-map-panel="transceiver">
                      <div class="drop-inner">
                        <h3>RF backend</h3>
                        <p>The RF backend is responsible for all wireless communication within the system. A single transceiver IC handles both transmit and receive operation, simplifying the overall RF architecture. Carefully selected matching components are used to ensure proper impedance matching and efficient RF performance.</p>
                      </div>
                    </div>
                  </div>
                </section>
              </div>
            </div>
          </div>   
    </section>


    <!-- Schematics (Top-level) -->
    <section class="drop" data-drop>
      <a class="section-link top-link" href="#" data-drop-btn>Schematics</a>

      <div class="drop-panel" hidden aria-hidden="true" data-drop-panel>
        <div class="drop-inner">
          <div class="schematics-list">

            <a class="section-link" href="#" data-sub-btn="battery-management">Battery management</a>
            <div class="drop-panel" hidden aria-hidden="true" data-sub-panel="battery-management">
              <div class="drop-inner">
                <img src="/assets/photos/fm/battery-management.png" alt="Battery management schematic">
                <p>The BATMAN battery management subsystem is built around the Texas Instruments BQ77905 battery manager and is responsible for safely managing a single 18650 Li-ion cell. Its primary role is to protect the battery by providing over-voltage, under-voltage, over-current, short-circuit, and temperature protection. The BATMAN IC continuously monitors cell voltage, charge and discharge current through a sense resistor, and cell temperature using an external NTC thermistor. When unsafe conditions are detected, the device drives two external MOSFETs to disconnect the battery from the system load. Status signals such as CHG, DSG, and LD give the system controller real-time insight into battery and load conditions. Within the overall design, this subsystem forms the core of the power supply, ensuring user safety and protecting all downstream electronics. By isolating fault conditions at the battery level, BATMAN improves system reliability and allows the transceiver to operate safely from a removable high-energy Li-ion cell.</p>
              </div>
            </div>

            <a class="section-link" href="#" data-sub-btn="voltage-regulator">Voltage regulator</a>
            <div class="drop-panel" hidden aria-hidden="true" data-sub-panel="voltage-regulator">
              <div class="drop-inner">
                <img src="/assets/photos/fm/voltage-regulator.png" alt="Voltage regulator schematic">
                <p>The S-1172 voltage regulator stage is used to condition battery power for the rest of the system. It takes the protected battery output (PREBAT) and generates a stable, regulated supply rail for the downstream digital and RF electronics. Input and output capacitors are placed close to the device to ensure regulator stability, suppress noise, and handle transient current demands. The ON/OFF control pin allows the regulator to be cleanly enabled or disabled as part of the system power-up sequence. By regulating the inherently variable voltage of a single 18650 Li-ion cell, this stage helps prevent brownouts and over-voltage stress on sensitive components. In the overall design, this block sits directly after the BATMAN battery manager and serves as the final power-conditioning step, ensuring reliable operation across the full battery discharge curve.</p>
              </div>
            </div>

            <a class="section-link" href="#" data-sub-btn="battery-percentage">Battery percentage</a>
            <div class="drop-panel" hidden aria-hidden="true" data-sub-panel="battery-percentage">
              <div class="drop-inner">
                <img src="/assets/photos/fm/battery-percentage.png" alt="Battery percentage schematic">
                <p>The battery voltage monitoring circuit measures the protected battery rail and provides a low-power way for the microcontroller to estimate remaining charge. A high-value resistor divider is used to scale the battery voltage while keeping continuous current draw to a minimum. The divided signal is buffered using a TC75 op-amp, which presents a stable, low-impedance output that isn’t affected by ADC loading. This buffered voltage is then digitized by the MCP3021 I²C ADC. Using a dedicated ADC allows the microcontroller to periodically sample the battery voltage without directly loading the battery or sensitive analog node. In the overall system, this block supports battery percentage estimation and low-battery warnings while maintaining good power efficiency.</p>
              </div>
            </div>

            <a class="section-link" href="#" data-sub-btn="microcontroller">Microcontroller</a>
            <div class="drop-panel" hidden aria-hidden="true" data-sub-panel="microcontroller">
              <div class="drop-inner">
                <img src="/assets/photos/fm/microcontroller.png" alt="Microcontroller schematic">
                <p>The microcontroller serves as the central controller for the system, handling high-level logic, coordination between subsystems, and all user interaction. It communicates with peripherals over SPI and I²C, processes external interrupts from user inputs, and manages system states such as transmit/receive operation, display updates, and power behavior. Separate power and ground pins are used to help isolate digital and analog domains and reduce noise sensitivity. Firmware programming and debugging are supported through dedicated ICSP connections. By relying on interrupt-driven inputs rather than continuous polling, the system remains responsive while minimizing processor overhead. In the context of the full design, the microcontroller ties together the RF, power management, audio, and user interface subsystems.</p>
              </div>
            </div>

            <a class="section-link" href="#" data-sub-btn="glcd">GLCD</a>
            <div class="drop-panel" hidden aria-hidden="true" data-sub-panel="glcd">
              <div class="drop-inner">
                <img src="/assets/photos/fm/glcd.png" alt="GLCD schematic">
                <p>The graphical LCD serves as the primary visual interface for the device, presenting system status and user feedback during operation. It is powered directly from the system supply and communicates with the microcontroller over an SPI interface. Dedicated control lines manage reset, data/command selection, chip select, and backlight control, allowing the display to be updated efficiently and flexibly. The backlight enable line provides the option to adjust brightness or disable the backlight entirely to save power when the display is not in use. Within the overall system, this module functions as the main user interface, displaying information such as battery level, operating mode, and channel selection.</p>
              </div>
            </div>

            <a class="section-link" href="#" data-sub-btn="interrupts">Interrupts</a>
            <div class="drop-panel" hidden aria-hidden="true" data-sub-panel="interrupts">
              <div class="drop-inner">
                <img src="/assets/photos/fm/interrupts.png" alt="Interrupts schematic">
                <p>The input and interrupt circuit handles all user button interactions and converts them into clean, reliable digital signals for the microcontroller. Each pushbutton is biased from the battery rail and uses an RC network to debounce the mechanical switch action. The conditioned signals are routed directly to dedicated external interrupt pins, allowing the system to respond immediately to user input rather than relying on continuous polling. A dual-switch device is used to reduce component count while still maintaining independent inputs. This approach lowers processor overhead and improves responsiveness. In the context of the full system, this block enables smooth and reliable user control for mode selection, adjustments, and transmit/receive operation.</p>
              </div>
            </div>

            <a class="section-link" href="#" data-sub-btn="icsp">ICSP</a>
            <div class="drop-panel" hidden aria-hidden="true" data-sub-panel="icsp">
              <div class="drop-inner">
                <img src="/assets/photos/fm/icsp.png" alt="ICSP schematic">
                <p>The ICSP programming interface allows the microcontroller to be programmed and debugged directly on the board without needing to remove it from the circuit. It brings out the necessary power, ground, reset, and programming data and clock lines needed for in-circuit programming. This makes firmware updates, debugging, and recovery much easier during development and testing. The interface follows Microchip’s standard ICSP pinout, ensuring compatibility with common programming tools. Keeping this header on the board simplified iteration and troubleshooting throughout the project, and it serves as the critical link between firmware development and the physical hardware.</p>
              </div>
            </div>

            <a class="section-link" href="#" data-sub-btn="reset">Reset</a>
            <div class="drop-panel" hidden aria-hidden="true" data-sub-panel="reset">
              <div class="drop-inner">
                <img src="/assets/photos/fm/reset.png" alt="Reset schematic">
                <p>The reset and startup circuit ensures the microcontroller always powers up in a known, stable state and can be reliably reset by the user when needed. A pull-up resistor holds the reset line high during normal operation, while a pushbutton allows the reset line to be asserted manually. An RC network adds a short delay during power-up to prevent false resets while the supply voltage is ramping. A series resistor helps protect the reset pin and improves signal integrity. A jumper is included to provide flexibility during development and troubleshooting by allowing the reset behavior to be modified. Together, this circuitry ensures predictable startup behavior and reliable recovery from fault conditions.</p>
              </div>
            </div>

            <a class="section-link" href="#" data-sub-btn="decoupling">Decoupling</a>
            <div class="drop-panel" hidden aria-hidden="true" data-sub-panel="decoupling">
              <div class="drop-inner">
                <img src="/assets/photos/fm/decoupling.png" alt="Decoupling schematic">
                <p>The power decoupling network stabilizes the supply rails that feed both the digital and analog sections of the system. Local bypass capacitors provide a low-impedance path to ground for high-frequency noise and short current spikes caused by switching activity. Separating the VDD and AVDD domains helps prevent digital noise from coupling into more sensitive analog circuitry, improving overall signal quality. By placing the decoupling components as close as possible to the load, disturbances are filtered before they can spread across the board, reducing the chance of erratic behavior or unintended resets. In the context of the full design, this block is critical to the reliable operation of the microcontroller and other mixed-signal components.</p>
              </div>
            </div>

            <a class="section-link" href="#" data-sub-btn="transceiver">Transceiver</a>
            <div class="drop-panel" hidden aria-hidden="true" data-sub-panel="transceiver">
              <div class="drop-inner">
                <img src="/assets/photos/fm/transceiver.png" alt="Transceiver schematic">
                <p>The FM transceiver block is responsible for all wireless transmit and receive functionality, as well as interfacing the audio signals used by the system. The SI4720 integrates modulation, demodulation, and RF signal processing into a single device, which helped reduce both external component count and overall RF design complexity. An external antenna, along with a matching inductor, forms the RF front end to support efficient transmission and reception. The microcontroller communicates with the transceiver over a serial interface, allowing the operating frequency, mode, and power settings to be configured in software. Audio from the microphone is AC-coupled into the transceiver, while received audio is routed to the downstream amplifier. As a whole, this block acts as the core communication engine that enables two-way FM voice operation.</p>
              </div>
            </div>

            <a class="section-link" href="#" data-sub-btn="crystal-oscillator">Crystal oscillator</a>
            <div class="drop-panel" hidden aria-hidden="true" data-sub-panel="crystal-oscillator">
              <div class="drop-inner">
                <img src="/assets/photos/fm/crystal-oscillator.png" alt="Crystal oscillator schematic">
                <p>The crystal oscillator supplies a stable reference clock for the transceiver’s internal timing and frequency generation. A 32.768 kHz crystal, paired with matched load capacitors, is used to ensure reliable startup and long-term frequency stability. This low-frequency reference enables consistent tuning and repeatable RF performance. Careful grounding and symmetric loading were used to reduce phase noise and avoid startup issues. In the overall system, this clock source isi>s foundational to accurate modulation, demodulation, and channel stability.</p>
              </div>
            </div>

            <a class="section-link" href="#" data-sub-btn="audio-amplifier">Audio amplifier</a>
            <div class="drop-panel" hidden aria-hidden="true" data-sub-panel="audio-amplifier">
              <div class="drop-inner">
                <img src="/assets/photos/fm/audio-amplifier.png" alt="Audio amplifier schematic">
                <p>The audio amplifier stage takes the low-level audio output from the transceiver and boosts it to a level suitable for driving the speaker. The TPA321 is configured in a bridge-tied load arrangement, allowing higher output power from a low supply voltage without the need for a large coupling capacitor. Input coupling and biasing components condition the signal and remove any DC offset before amplification. Local decoupling is used to keep the amplifier stable under changing audio loads. A shutdown control line allows the amplifier to be disabled when audio output isn’t needed, helping reduce overall power consumption. In the system as a whole, this block translates the demodulated RF signal into clear, audible sound for the user.</p>
              </div>
            </div>

          </div>
        </div>
      </div>
    </section>

    <!-- (Optional) placeholders for the other top-level headings you had -->
    <section class="drop" data-drop>
      <a class="section-link top-link" href="#" data-drop-btn>Hardware Implementation</a>
      <div class="drop-panel" hidden aria-hidden="true" data-drop-panel>
        <div class="drop-inner">
          <div class="hw-grid">
          
            <div class="hw-card">
              <div class="zoom-wrap" data-zoom="2.0" data-lens="220">
                <img
                  class="zoom-img"
                  src="/assets/photos/fm/pcb-front.png"
                  alt="PCB front"
                />
                <div class="zoom-lens" aria-hidden="true"></div>
              </div>
              <div class="hw-cap">Front</div>
              <p></p>
            </div>
          
            <div class="hw-card">
              <div class="zoom-wrap" data-zoom="2.0" data-lens="220">
                <img
                  class="zoom-img"
                  src="/assets/photos/fm/pcb-back.png"
                  alt="PCB rear"
                />
                <div class="zoom-lens" aria-hidden="true"></div>
              </div>
              <div class="hw-cap">Rear</div>
            </div>
          
          </div>

        <p>The PCB layout was approached with functional partitioning and signal integrity as primary goals. Components were grouped by subsystem—such as MCU support, RF front end, audio, and power management—to keep routing logical and reduce trace lengths for sensitive signals. High pin-count devices were placed centrally to simplify fan-out and reduce routing congestion, while decoupling capacitors were positioned as close as possible to IC power pins to help control supply noise. A continuous ground reference and short return paths were maintained across the board to improve overall stability and robustness.</p>

<hr><p>The RF transceiver was intentionally placed in the bottom-right corner of the PCB, close to the antenna connection point (E1). Positioning the RF section near the antenna minimized the length of sensitive RF and small-signal traces, reducing the chance of noise coupling from digital logic and power circuitry elsewhere on the board. Localizing the RF components also made impedance-aware routing more straightforward and helped keep the antenna interface clean and predictable.</p>
        </div>
      </div>
    </section>

    <section class="drop" data-drop>
      <a class="section-link top-link" href="#" data-drop-btn>Control</a>
      <div class="drop-panel" hidden aria-hidden="true" data-drop-panel>
        <div class="drop-inner">
                  <div class="zoom-wrap" data-zoom="2.0" data-lens="220">
                  <img class="zoom-img"
                       src="/assets/photos/fm/soft-flow.png"
                       alt="Software block diagram" />
                  <div class="zoom-lens" aria-hidden="true"></div>
                  </div>
                <p>
On startup, the system initializes all hardware modules and I/O lines, then brings up the graphical LCD to show the current operating state. During normal use, the radio stays in receive mode and continuously listens for user input. The selected mode determines what the up and down buttons control, allowing the user to switch channels, adjust the audio volume, or change the display brightness. When the transmit button is pressed, the system briefly switches into transmit mode and automatically returns to receive once the button is released. This loop runs continuously, allowing the device to respond quickly and predictably to user interactions.
                </p>
              </div>
            </div>
    </section>

    <section class="drop" data-drop>
      <a class="section-link top-link" href="#" data-drop-btn>Form &amp; Enclosure</a>
      <div class="drop-panel" hidden aria-hidden="true" data-drop-panel>
        <div class="drop-inner">
          
          <div style="text-align: center; margin: 20px 0;">
            <img src="/assets/photos/fm/physical.png" 
                 alt="FM Transceiver PCB" 
                 style="max-width: 100%; height: auto;">
          </div>
          
          <p>
            Physical assembled prototype.
          </p>


          
          <div class="stl-viewer" data-stl="/assets/stl/mainbody.stl">
  <canvas class="stl-canvas"></canvas>
<div class="stl-hint" aria-hidden="true">⟲ Drag </div>
<p>Interactive Fusion 360 enclosure design.</p>
</div>
          
          </div>
        </div>
      </section>
    <section class="drop" data-drop>
      <a class="section-link top-link" href="#" data-drop-btn>Skills and Outcomes</a>
      <div class="drop-panel" hidden aria-hidden="true" data-drop-panel>
        <div class="drop-inner">
          <p>This project was a major learning experience for me and involved several first-time milestones in both hardware and mechanical design. It was my first time assembling a PCB using a reflow oven, with most of the passive components soldered by hand, which forced me to be deliberate about placement, inspection, and rework. I also designed a custom enclosure in CAD for the first time, learning how mechanical constraints, board geometry, and connector placement all have to work together in a real device. While the system was not fully functional in its final state, the failure was traced back to a timing issue in my SPI library that prevented the SI4720 transceiver from initializing correctly—specifically, incorrect clock polarity and setup timing during early configuration commands. Debugging this exposed how sensitive RF ICs can be to low-level digital timing and reinforced the importance of validating firmware assumptions against datasheet requirements. Through this project, I developed a much stronger understanding of RF-aware PCB layout, power integrity, decoupling, and subsystem partitioning, as well as practical experience diagnosing problems that span firmware, digital interfaces, and analog RF hardware.</p>
        </div>
      </div>
    </section>

    <script>
      // ===== helpers (ONLY ONCE) =====
      function shiftToViewportCenter(el){
        const r = el.getBoundingClientRect();
        const elCenter = r.left + r.width / 2;
        const viewportCenter = window.innerWidth / 2;
        return viewportCenter - elCenter;
      }

      function waitForTransition(el, prop){
        return new Promise((resolve) => {
          const onEnd = (e) => {
            if (e.propertyName !== prop) return;
            el.removeEventListener("transitionend", onEnd);
            resolve();
          };
          el.addEventListener("transitionend", onEnd);
        });
      }

      async function openPanel(panel){
        panel.hidden = false;
        panel.setAttribute("aria-hidden", "false");

        panel.style.maxHeight = "0px";
        panel.getBoundingClientRect();

        panel.classList.add("is-open");
        panel.style.maxHeight = panel.scrollHeight + "px";

        await waitForTransition(panel, "max-height");
        panel.style.maxHeight = "none";
      }

      async function closePanel(panel){
        panel.style.maxHeight = panel.scrollHeight + "px";
        panel.getBoundingClientRect();

        panel.classList.remove("is-open");
        panel.style.maxHeight = "0px";

        await waitForTransition(panel, "max-height");

        panel.hidden = true;
        panel.setAttribute("aria-hidden", "true");
      }

      function hardCloseInside(root){
        root.querySelectorAll(".drop-panel").forEach((p) => {
          p.classList.remove("is-open");
          p.style.maxHeight = "0px";
          p.hidden = true;
          p.setAttribute("aria-hidden", "true");
        });
        root.querySelectorAll(".section-link").forEach((a) => a.classList.remove("is-selected"));
      }

      // ===== Generic dropdowns (NO IDs) =====
      document.querySelectorAll("[data-drop]").forEach((drop) => {
        const topBtn = drop.querySelector("[data-drop-btn]");
        const topPanel = drop.querySelector("[data-drop-panel]");
        if (!topBtn || !topPanel) return;

        let open = false;
        let sliding = false;

        async function slideToCenter(){
          if (sliding) return;
          sliding = true;

          topBtn.style.transform = "translateX(0px)";
          topBtn.getBoundingClientRect();

          requestAnimationFrame(() => {
            const shift = shiftToViewportCenter(topBtn);
            topBtn.style.transform = `translateX(${shift}px)`;
          });

          await waitForTransition(topBtn, "transform");
          sliding = false;
        }

        async function slideBackLeft(){
          if (sliding) return;
          sliding = true;

          topBtn.style.transform = "translateX(0px)";
          await waitForTransition(topBtn, "transform");

          sliding = false;
        }

        topBtn.addEventListener("click", async (e) => {
          e.preventDefault();
          if (sliding) return;

          open = !open;

          if (open){
            topBtn.classList.add("is-selected");
            await slideToCenter();
            await openPanel(topPanel);
          } else {
            hardCloseInside(topPanel);
            await closePanel(topPanel);
            topBtn.classList.remove("is-selected");
            await slideBackLeft();
          }
        });

        // nested panels scoped to THIS dropdown only
        drop.querySelectorAll("[data-sub-btn]").forEach((btn) => {
          const key = btn.getAttribute("data-sub-btn");
          const panel = drop.querySelector(`[data-sub-panel="${key}"]`);
          if (!panel) return;

          btn.addEventListener("click", async (e) => {
            e.preventDefault();
            if (topPanel.hidden) return;

            if (panel.hidden){
              btn.classList.add("is-selected");
              await openPanel(panel);
            } else {
              await closePanel(panel);
              btn.classList.remove("is-selected");
            }
          });
        });

        // keep centered & heights good on resize (scoped)
        window.addEventListener("resize", () => {
          if (open){
            topBtn.style.transform = `translateX(${shiftToViewportCenter(topBtn)}px)`;
            if (!topPanel.hidden && topPanel.style.maxHeight !== "none"){
              topPanel.style.maxHeight = topPanel.scrollHeight + "px";
            }
          }
        });
      });

      // ===== Subsystem map click behavior (NO IDs) =====
      document.querySelectorAll(".subsystem-map").forEach((map) => {
        const regions = Array.from(map.querySelectorAll(".map-overlay .hot"));
        const panels = Array.from(map.querySelectorAll("[data-map-panel]"));
        const panelByKey = new Map(panels.map(p => [p.getAttribute("data-map-panel"), p]));

        let active = null;

        regions.forEach((r) => {
          r.addEventListener("click", async () => {
            const key = r.dataset.target;
            const panel = panelByKey.get(key);
            if (!panel) return;

            if (active === key){
              r.classList.remove("is-active");
              await closePanel(panel);
              active = null;
              return;
            }

            if (active){
              const prevRegion = regions.find(x => x.dataset.target === active);
              const prevPanel = panelByKey.get(active);
              if (prevRegion) prevRegion.classList.remove("is-active");
              if (prevPanel && !prevPanel.hidden) await closePanel(prevPanel);
            }

            regions.forEach(x => x.classList.toggle("is-active", x.dataset.target === key));
            await openPanel(panel);
            active = key;

            panel.scrollIntoView({ behavior: "smooth", block: "start" });
          });
        });
      });

      // ===== Pan/zoom (unchanged, already ID-free) =====
      (function setupLensZoom(){
        document.querySelectorAll(".zoom-wrap").forEach((wrap) => {
          const img = wrap.querySelector(".zoom-img");
          const lens = wrap.querySelector(".zoom-lens");
          if (!img || !lens) return;

          function getNum(attr, fallback){
            const v = Number(wrap.dataset[attr]);
            return Number.isFinite(v) ? v : fallback;
          }

          function syncLensSize(){
            const s = getNum("lens", 220);
            lens.style.width = s + "px";
            lens.style.height = s + "px";
            return s;
          }

          function updateBackground(){
            const r = img.getBoundingClientRect();
            const zoom = getNum("zoom", 2.0);

            lens.style.backgroundImage = `url(${img.src})`;
            lens.style.backgroundSize = `${r.width * zoom}px ${r.height * zoom}px`;
            return { r, zoom };
          }

          function setPos(e){
            const { r, zoom } = updateBackground();
            const lensSize = syncLensSize();
            const half = lensSize / 2;

            let x = e.clientX - r.left;
            let y = e.clientY - r.top;

            x = Math.max(0, Math.min(x, r.width));
            y = Math.max(0, Math.min(y, r.height));

            const lx = x - half;
            const ly = y - half;

            lens.style.transform = `translate(${lx}px, ${ly}px)`;

            const bx = -x * zoom + half;
            const by = -y * zoom + half;
            lens.style.backgroundPosition = `${bx}px ${by}px`;
          }

          function onEnter(){
            syncLensSize();
            updateBackground();
            lens.style.opacity = "1";
          }

          function onLeave(){
            lens.style.opacity = "0";
            lens.style.transform = "translate(-9999px, -9999px)";
          }

          wrap.addEventListener("mouseenter", onEnter);
          wrap.addEventListener("mousemove", setPos);
          wrap.addEventListener("mouseleave", onLeave);

          window.addEventListener("resize", () => {
            if (lens.style.opacity === "1") updateBackground();
          });
        });
      })();
     

   
    </script>

  </div>
        <script type="module">
import * as THREE from "three";
import { OrbitControls } from "three/addons/controls/OrbitControls.js";
import { STLLoader } from "three/addons/loaders/STLLoader.js";



  function initStlViewer(root){
    const canvas = root.querySelector(".stl-canvas");
    const url = root.getAttribute("data-stl");
    console.log("STL URL:", url);
    if (!canvas || !url) return;
      const renderer = new THREE.WebGLRenderer({ canvas, antialias: true, alpha: true });
    renderer.setPixelRatio(Math.min(window.devicePixelRatio || 1, 2));

    const scene = new THREE.Scene();

    const camera = new THREE.PerspectiveCamera(45, 1, 0.01, 1000);
    camera.position.set(0, 0.6, 1.6);
    camera.up.set(0, 1, 0);

    const controls = new OrbitControls(camera, canvas);
    controls.enableDamping = true;
    controls.dampingFactor = 0.08;
    controls.enablePan = true;
    controls.enableZoom = true;
    controls.enableRotate = true;

    controls.minDistance = 0;
    controls.maxDistance = Infinity;

    controls.minPolarAngle = 0;
    controls.maxPolarAngle = Math.PI;

    controls.minAzimuthAngle = -Infinity;
    controls.maxAzimuthAngle = Infinity;
    // ===== one-time hint ("Drag to rotate") =====
// ===== one-time hint, triggered on first hover =====
const hint = root.querySelector(".stl-hint");
const hintKey = "stl_hint_seen_v1";

if (hint && !localStorage.getItem(hintKey)) {
  const showHintOnce = () => {
    localStorage.setItem(hintKey, "1");
    hint.classList.add("is-show");
    setTimeout(() => hint.classList.remove("is-show"), 2200);
    root.removeEventListener("mouseenter", showHintOnce);
  };

  // show only after the user actually hovers the viewer
  root.addEventListener("mouseenter", showHintOnce, { once: true });
}




    // lights
// lights (more shape definition)
scene.add(new THREE.AmbientLight(0xffffff, 0.35));

const key = new THREE.DirectionalLight(0xffffff, 1.1);
key.position.set(2.5, 3.5, 2.0);
scene.add(key);

const fill = new THREE.DirectionalLight(0xffffff, 0.55);
fill.position.set(-2.0, 1.5, 1.5);
scene.add(fill);

const rim = new THREE.DirectionalLight(0xffffff, 0.75);
rim.position.set(-1.5, 2.5, -2.5);
scene.add(rim);
    renderer.shadowMap.enabled = true;
renderer.shadowMap.type = THREE.PCFSoftShadowMap;
key.castShadow = true;


    // material
   // material (more contrast + clearer shape)
const mat = new THREE.MeshPhysicalMaterial({
  color: 0xd6dbe3,      // light neutral
  metalness: 0.0,
  roughness: 0.25,
  clearcoat: 0.25,
  clearcoatRoughness: 0.2,
  sheen: 0.15,
  sheenRoughness: 0.6
});


    let mesh = null;


    const loader = new STLLoader();
    loader.load(
      url,
      (geom) => {
        geom.computeVertexNormals();

        // center + scale to fit
        geom.computeBoundingBox();
        const box = geom.boundingBox;
        const size = new THREE.Vector3();
        box.getSize(size);

        const center = new THREE.Vector3();
        box.getCenter(center);
        geom.translate(-center.x, -center.y, -center.z);

        const maxDim = Math.max(size.x, size.y, size.z) || 1;
        const target = 1.0;
        const scale = target / maxDim;

        const group = new THREE.Group();

        mesh = new THREE.Mesh(geom, mat);
        mesh.scale.setScalar(scale);
        group.add(mesh);
        mesh.rotation.x = -Math.PI / 2; 




        scene.add(group);

      
camera.position.set(0, 0, 1.8);  
controls.target.set(0, 0, 0);
controls.update();

      },
      undefined,
 (err) => {
  console.error("STL load failed:", err, "URL:", url);
}
     );

    function resize(){
  const rect = canvas.getBoundingClientRect();
  const w = Math.max(1, Math.floor(rect.width));
  const h = Math.max(1, Math.floor(rect.height));

  // if still hidden/collapsed, don't lock in 1x1 forever
  if (w < 5 || h < 5) return;

  renderer.setSize(w, h, false);
  camera.aspect = w / h;
  camera.updateProjectionMatrix();
}

// Call once now (might do nothing if hidden)
resize();

// Resize whenever layout changes (e.g., dropdown opens)
const ro = new ResizeObserver(() => resize());
ro.observe(root);

// Also keep the normal window resize
window.addEventListener("resize", resize);


    // render loop
    function animate(){
      requestAnimationFrame(animate);
      controls.update();

      renderer.render(scene, camera);
    }
    animate();

    window.addEventListener("resize", resize);
  }

  document.querySelectorAll(".stl-viewer").forEach(initStlViewer);
</script>


</body>
</html>
