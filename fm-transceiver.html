<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>FM Transceiver | Denys Shlyakhtovskyy</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <link rel="stylesheet" href="style.css">

  <!-- minimal page-only layout helpers (no global changes) -->
  <style>
    .schematics-list{
      text-align: center;
      margin-top: 8px;
    }
    .schematics-list .section-link{
      display: block;
      width: 100%;
      margin: 14px 0 8px 0; /* vertical rhythm */
    }
    .schematics-list .drop-panel{
      text-align: center;   /* image + text centered */
      margin: 0 auto 8px auto;
      max-width: 70ch;
    }
    .schematics-list .drop-panel img{
      margin: 0 auto;       /* center image */
    }
    .schematics-list .drop-panel p{
      text-align: center;
      margin-top: 10px;
    }
    /* make top-level headers stack vertically */
/* stack the two top-level headers vertically without changing their width */
#schematicsLink,
#softwareLink{
  display: block;         /* forces new line */
  width: fit-content;     /* keeps natural width so centering math works */
  margin: 14px 0 8px 0;   /* vertical rhythm */
}


  </style>
</head>

<body>

  <div class="container">
    <a class="back" href="./projects.html">← Back to Projects</a>
    <h1>FM Transceiver</h1>

    <p>
  This project was made for the Electronics Engineering program at Okanagan College in 2022. The idea was to integrate digital control architecture with RF components to create a low power 2-way FM radio (pair of walkie talkies); Below is a technical description of the project.

    </p>

    <hr>
<!-- Main header button -->
<a class="section-link" id="softwareLink" href="#">Overview</a>

<div id="softwarePanel" class="drop-panel" hidden aria-hidden="true">
  <div class="drop-inner">
    <div class="schematics-list">

      <a class="section-link" href="#" data-sw="software-description">Executive summary</a>
      <div class="drop-panel" id="sw-software-description" hidden aria-hidden="true">
        <div class="drop-inner">
          <p>The FM Transceiver project aims to create a simple, effective, wireless solution for indoor two-way communication. Two devices were designed and built, each organized around five core functional blocks: system input, RF backend, MCU support, system output, and power supply, along with a small set of supporting components. The devices use frequency modulation (FM), which offers better noise immunity and stability compared to amplitude modulation. Received audio is output through an 8 Ω speaker driven by a low-power audio amplifier. A Microchip PIC24FJ1024GB606 microcontroller is used to handle input processing and system control due to its simplicity and flexible I/O. RF communication is handled by the SI4720 transceiver, a highly integrated solution that manages all RF functions within the system.</p>
        </div>
      </div>

      <a class="section-link" href="#" data-sw="software-flowchart">Scope</a>
      <div class="drop-panel" id="sw-software-flowchart" hidden aria-hidden="true">
        <div class="drop-inner">
          <p>The FM Transceiver Pair project focuses on the development of two portable RF transceivers designed for simple two-way communication. Each device includes a user interface composed of four buttons and a single switch: a lit transmit button, a mode select button, a pair of up/down buttons, and an on/off switch. In addition to the controls, each unit incorporates a 1.3-inch display and speaker-based audio output. Because the devices are powered by removable batteries, a battery management system is included to ensure both user safety and battery protection. The project also involves testing activities, including software debugging and optimization to reduce unnecessary power consumption, as well as verification of RF performance against the project requirements.

Several scope adjustments were made over the course of the project to improve feasibility and increase the likelihood of success. An externally chargeable battery was adopted to reduce system complexity, and a single 18650 lithium-ion cell was selected due to better availability, lower cost, and higher energy density compared to lithium-polymer alternatives. Later design changes included the addition of an external ADC to simplify battery charge monitoring and reduce overall hardware and software complexity. The design was also revised to use a single speaker rather than multiple speakers in response to parts availability constraints.
</p>
        </div>
      </div>

      <a class="section-link" href="#" data-sw="software-code">Control</a>
<div class="drop-panel" id="sw-software-code" hidden aria-hidden="true">
  <div class="drop-inner">

    <div class="zoom-wrap" data-zoom="1.2" data-lens="220">
      <img
        class="zoom-img"
        src="assets/photos/fm/soft-flow.png"
        alt="Software block diagram"
      />
      <div class="zoom-lens" aria-hidden="true"></div>
    </div>

    <p>
      The system begins by initializing all modules and I/O ports before displaying key operating metrics on the graphical LCD. During normal operation, the transceiver remains in receive mode while continuously monitoring user inputs. The mode selection determines the function of the up and down buttons, allowing the user to change the active channel, adjust audio volume, or modify screen brightness. If the transmit button is pressed, the system temporarily switches to transmit mode and returns to receive mode once the button is released. This control loop repeats continuously to enable responsive, real-time interaction with the device.
    </p>

  </div>
</div>

       <a class="section-link" href="#" data-sw="block-diagram">Block Diagram</a>
      <div class="drop-panel" id="sw-block-diagram" hidden aria-hidden="true">
        <div class="drop-inner">
          <!--DROPDOWN START-->
<!-- Interactive subsystem diagram -->
<section class="subsystem-map">
  <div class="map-wrap" aria-label="Subsystem diagram">
    <img
      src="assets/photos/fm/block-diagram.png"
      alt="FM Transceiver subsystem block diagram"
    />

    <!-- SVG overlay: viewBox matches your screenshot size (872 x 804) -->
    <svg class="map-overlay" viewBox="0 0 872 804" aria-hidden="true">
      <!-- BATTERY MANAGEMENT (red dashed area) -->
      <rect class="hot hot-red" data-target="battery-management"
            x="77" y="190" width="736" height="137" rx="18" />

      <!-- INTERRUPTS / BUTTONS (blue dashed area) -->
      <rect class="hot hot-blue" data-target="interrupts"
            x="260" y="17" width="325" height="307" rx="18" />

      <!-- XTAL + DECOUPLING (cyan dashed area) -->
      <rect class="hot hot-cyan" data-target="decoupling"
            x="78" y="330" width="195" height="142" rx="18" />

      <!-- GLCD / SCREEN (black dashed area) -->
      <rect class="hot hot-black" data-target="glcd"
            x="85" y="495" width="465" height="120" rx="18" />

      <!-- AUDIO AMPLIFIER (grey) -->
      <rect class="hot hot-audio" data-target="audio-amplifier"
            x="325" y="355" width="225" height="120" rx="18" />

      <!-- MICROCONTROLLER (darker grey) -->
      <rect class="hot hot-uc" data-target="microcontroller"
            x="340" y="633" width="210" height="120" rx="18" />

      <!-- TRANSCEIVER (magenta dashed area) -->
      <rect class="hot hot-magenta" data-target="transceiver"
            x="555" y="345" width="265" height="425" rx="18" />
    </svg>
  </div>

  <!-- Dropdown panels (one per subsystem) -->
  <div class="map-panels">
    <div id="panel-battery-management" class="drop-panel" hidden aria-hidden="true">
      <div class="drop-inner">
        <h3>Battery management</h3>
        <p>(Drop content here)</p>
      </div>
    </div>

    <div id="panel-interrupts" class="drop-panel" hidden aria-hidden="true">
      <div class="drop-inner">
        <h3>Interrupts</h3>
        <p>(Drop content here)</p>
      </div>
    </div>

    <div id="panel-decoupling" class="drop-panel" hidden aria-hidden="true">
      <div class="drop-inner">
        <h3>Decoupling</h3>
        <p>(Drop content here)</p>
      </div>
    </div>

    <div id="panel-glcd" class="drop-panel" hidden aria-hidden="true">
      <div class="drop-inner">
        <h3>GLCD</h3>
        <p>(Drop content here)</p>
      </div>
    </div>

    <div id="panel-audio-amplifier" class="drop-panel" hidden aria-hidden="true">
      <div class="drop-inner">
        <h3>Audio amplifier</h3>
        <p>(Drop content here)</p>
      </div>
    </div>

    <div id="panel-microcontroller" class="drop-panel" hidden aria-hidden="true">
      <div class="drop-inner">
        <h3>Microcontroller</h3>
        <p>(Drop content here)</p>
      </div>
    </div>

    <div id="panel-transceiver" class="drop-panel" hidden aria-hidden="true">
      <div class="drop-inner">
        <h3>Transceiver</h3>
        <p>(Drop content here)</p>
      </div>
    </div>
  </div>
</section>

<style>
  /* container */
  .map-wrap{
    position: relative;
    width: 100%;
    max-width: 900px;
    margin: 18px auto 10px;
  }
  .map-wrap img{
    width: 100%;
    height: auto;
    display: block;
    border-radius: 10px;
  }
  .map-overlay{
    position: absolute;
    inset: 0;
    width: 100%;
    height: 100%;
  }

  /* clickable regions: invisible until hover */
  .hot{
    fill: rgba(0,0,0,0);
    stroke: rgba(0,0,0,0);
    stroke-width: 3;
    cursor: pointer;
    transition: fill 180ms ease, stroke 180ms ease;
  }

  /* show outline on hover */
  .hot:hover{
    stroke: rgba(0,0,0,0.18);
  }

  /* keep visible when active */
  .hot.is-active{
    stroke: rgba(0,0,0,0.25);
  }

  /* hover/active fills by subsystem color */
  .hot-red:hover, .hot-red.is-active{
    fill: rgba(255, 0, 0, 0.14);
    stroke: rgba(255, 0, 0, 0.55);
  }

  .hot-blue:hover, .hot-blue.is-active{
    fill: rgba(0, 90, 255, 0.14);
    stroke: rgba(0, 90, 255, 0.55);
  }

  .hot-cyan:hover, .hot-cyan.is-active{
    fill: rgba(0, 200, 220, 0.14);
    stroke: rgba(0, 200, 220, 0.55);
  }

  .hot-black:hover, .hot-black.is-active{
    fill: rgba(0, 0, 0, 0.10);
    stroke: rgba(0, 0, 0, 0.55);
  }

  /* audio amp grey */
  .hot-audio:hover, .hot-audio.is-active{
    fill: rgba(120, 120, 120, 0.18);
    stroke: rgba(120, 120, 120, 0.70);
  }

  /* uC darker grey */
  .hot-uc:hover, .hot-uc.is-active{
    fill: rgba(60, 60, 60, 0.22);
    stroke: rgba(60, 60, 60, 0.80);
  }

  .hot-magenta:hover, .hot-magenta.is-active{
    fill: rgba(255, 0, 255, 0.12);
    stroke: rgba(255, 0, 255, 0.55);
  }

  /* panels */
  .map-panels{
    max-width: 900px;
    margin: 0 auto;
  }
  .map-panels h3{
    margin: 12px 0 6px;
  }
  /* --- image magnifier lens (only where .zoom-wrap exists) --- */
.zoom-wrap{
  position: relative;
  display: block;
  width: 100%;
  max-width: 900px;      /* optional */
  margin: 0 auto;
}

.zoom-img{
  display: block;
  width: 100%;
  height: auto;
  border-radius: 10px;   /* matches your site images */
}

.zoom-lens{
  position: absolute;
  left: 0;
  top: 0;
  width: 220px;          /* overridden by data-lens if set */
  height: 220px;
  border-radius: 16px;
  border: 2px solid #000;
  background-repeat: no-repeat;
  background-color: #fff;
  box-shadow: 0 10px 26px rgba(0,0,0,0.18);
  pointer-events: none;

  opacity: 0;
  transform: scale(0.96);
  transition: opacity 140ms ease, transform 140ms ease;
}
.zoom-wrap.is-on .zoom-lens{
  opacity: 1;
  transform: scale(1);
}

</style>
          
          <!--DROPDOWN END-->
        <!--  <p>(Drop code snippets or links here)</p>-->
        </div>
      </div>
    </div>    
  </div>
</div>
    <!-- Main header button -->
    <a class="section-link" id="schematicsLink" href="#">Schematics</a>

    <!-- Main dropdown content -->
    <div id="schematicsPanel" class="drop-panel" hidden aria-hidden="true">
      <div class="drop-inner">

        <div class="schematics-list">
          <!-- 1 -->
          <a class="section-link" href="#" data-dd="battery-management">Battery management</a>
          <div class="drop-panel" id="dd-battery-management" hidden aria-hidden="true">
            <div class="drop-inner">
              <img src="assets/photos/fm/battery-management.png" alt="Battery management schematic">
              <p>The BATMAN battery management subsystem for the FM Transceiver project and is centered
                around the Texas Instruments BQ77905 battery manager IC. 
                Its primary function is to safely manage a single 18650 
                Li-ion cell by providing over-voltage, under-voltage, 
                over-current, short-circuit, and temperature protection. 
                The BATMAN IC continuously monitors cell voltage, 
                charge/discharge current through a sense resistor, and cell 
                temperature via an external NTC thermistor. 
                Two external MOSFETs are driven by BATMAN to disconnect 
                the battery from the system load when unsafe conditions 
                are detected. Status outputs such as CHG, DSG, and LD provide 
                the system controller with real-time 
                information about battery and load state. 
                In the broader scope of the project, this subsystem forms the core of the power supply block, 
                ensuring user safety and protecting all downstream electronics. By isolating fault 
                conditions at the battery level, BATMAN improves overall system reliability 
                and allows the FM transceiver to operate safely from a removable high-energy Li-ion cell.
</p>
            </div>
          </div>

          <!-- 2 -->
          <a class="section-link" href="#" data-dd="voltage-regulator">Voltage regulator</a>
          <div class="drop-panel" id="dd-voltage-regulator" hidden aria-hidden="true">
            <div class="drop-inner">
              <img src="assets/photos/fm/voltage-regulator.png" alt="Voltage regulator schematic">
              <p>The S-1172 voltage regulator stage used to condition battery power for the rest of the system. 
                The regulator takes the protected battery output (PREBAT) and produces a stable, 
                regulated supply rail for sensitive electronics downstream. Input and output capacitors are 
                placed close to the device to ensure stability, suppress noise, and handle transient current demands. 
                The ON/OFF pin allows the regulator to be cleanly enabled or disabled as part of the system power-up sequence. 
                By regulating the inherently variable voltage of an 18650 Li-ion cell, this stage prevents brownouts 
                and over-voltage stress on digital and RF components. In the broader scope of the project, 
                this schematic sits directly after the BATMAN battery manager and acts as the final power conditioning 
                step. Together, these blocks ensure the transceiver operates reliably across the full battery discharge curve.</p>
            </div>
          </div>

          <!-- 3 -->
          <a class="section-link" href="#" data-dd="battery-percentage">Battery percentage</a>
          <div class="drop-panel" id="dd-battery-percentage" hidden aria-hidden="true">
            <div class="drop-inner">
              <img src="assets/photos/fm/battery-percentage.png" alt="Battery percentage schematic">
              <p>The battery voltage monitoring circuit measures the protected battery rail and provides a low-power, MCU-readable representation of remaining charge. A high-value resistor divider scales the battery voltage while minimizing continuous current draw. The TC75 op-amp buffers this divided signal, presenting a stable, low-impedance output that is insensitive to ADC loading. This buffered voltage is then fed into the MCP3021 I²C ADC for digitization. The ADC allows the microcontroller to periodically sample battery voltage without directly loading the battery or analog node. In the broader system, this block enables battery percentage estimation and low-battery warning functionality while preserving overall power efficiency.</p>
            </div>
          </div>

          <!-- 4 -->
          <a class="section-link" href="#" data-dd="microcontroller">Microcontroller</a>
          <div class="drop-panel" id="dd-microcontroller" hidden aria-hidden="true">
            <div class="drop-inner">
              <img src="assets/photos/fm/microcontroller.png" alt="Microcontroller schematic">
              <p>The microcontroller handles all high-level control, coordination, and user interaction for the system. It interfaces with peripherals over SPI and I²C, manages external interrupts from user inputs, and controls system states such as transmit/receive mode, display updates, and power behavior. Multiple power and ground pins are used to properly isolate digital and analog domains and reduce noise sensitivity. Programming and debugging are supported through dedicated ICSP lines. External interrupts allow responsive, event-driven input handling without continuous polling. In the broader project, this device acts as the central controller that ties together the RF, power management, audio, and user interface subsystems.
</p>
            </div>
          </div>

          <!-- 5 -->
          <a class="section-link" href="#" data-dd="glcd">GLCD</a>
          <div class="drop-panel" id="dd-glcd" hidden aria-hidden="true">
            <div class="drop-inner">
              <img src="assets/photos/fm/glcd.png" alt="GLCD schematic">
              <p>The graphical LCD interface provides the primary visual output for the device, displaying system state and user feedback. It is powered directly from the system supply and communicates with the microcontroller over an SPI interface. Dedicated control lines handle reset, data/command selection, chip select, and backlight control. This separation of control and data signals allows for efficient screen updates and flexible display operation. The backlight enable line allows brightness control or power savings when the display is not needed. In the overall project, this module serves as the main user interface, presenting information such as battery level, operating mode, and channel selection.
</p>
            </div>
          </div>

          <!-- 6 -->
          <a class="section-link" href="#" data-dd="interrupts">Interrupts</a>
          <div class="drop-panel" id="dd-interrupts" hidden aria-hidden="true">
            <div class="drop-inner">
              <img src="assets/photos/fm/interrupts.png" alt="Interrupts schematic">
              <p>The input and interrupt circuit captures all user button interactions and converts them into clean, reliable digital signals for the microcontroller. Each pushbutton is biased from the battery rail and uses an RC network to debounce the mechanical switch action. The resulting signals are routed directly to dedicated external interrupt pins, enabling immediate, event-driven response. One dual-switch device is used to reduce component count while maintaining independent inputs. This approach eliminates the need for constant polling and reduces processor overhead. In the broader system, this block provides responsive user control for mode selection, adjustments, and transmit/receive operation.</p>
            </div>
          </div>

          <!-- 7 -->
          <a class="section-link" href="#" data-dd="icsp">ICSP</a>
          <div class="drop-panel" id="dd-icsp" hidden aria-hidden="true">
            <div class="drop-inner">
              <img src="assets/photos/fm/icsp.png" alt="ICSP schematic">
              <p>The ICSP programming interface allows the microcontroller to be programmed and debugged in-circuit without removing it from the board. It exposes the required power, ground, reset, and programming data and clock lines. This enables firmware updates, debugging, and recovery during development and testing. The interface follows Microchip’s standard ICSP pinout for compatibility with common programming tools. Keeping this header on the board simplifies iteration and troubleshooting. In the overall project, it provides the essential link between firmware development and the physical hardware.
</p>
            </div>
          </div>

          <!-- 8 -->
          <a class="section-link" href="#" data-dd="reset">Reset</a>
          <div class="drop-panel" id="dd-reset" hidden aria-hidden="true">
            <div class="drop-inner">
              <img src="assets/photos/fm/reset.png" alt="Reset schematic">
              <p>The reset and startup circuit ensures the microcontroller enters a known, stable state during power-up and user-initiated resets. A pull-up resistor holds the reset line high under normal operation, while the pushbutton allows manual assertion of reset. An RC network introduces a brief delay at startup to prevent false triggering during supply ramp-up. A series resistor protects the reset pin and improves signal integrity. The jumper allows flexibility during development or troubleshooting by modifying reset behavior. In the overall system, this block guarantees predictable boot behavior and reliable recovery from fault conditions.
</p>
            </div>
          </div>

          <!-- 9 -->
          <a class="section-link" href="#" data-dd="decoupling">Decoupling</a>
          <div class="drop-panel" id="dd-decoupling" hidden aria-hidden="true">
            <div class="drop-inner">
              <img src="assets/photos/fm/decoupling.png" alt="Decoupling schematic">
              <p>The power decoupling network stabilizes the supply rails feeding the digital and analog sections of the system. Local bypass capacitors provide a low-impedance path to ground for high-frequency noise and transient current spikes. Separating VDD and AVDD domains helps reduce coupling between digital switching noise and sensitive analog circuitry. This layout improves power integrity and overall signal quality across the board. By filtering disturbances close to the load, the circuit protects against erratic behavior and resets. In the broader project, this block is critical for reliable operation of the microcontroller and mixed-signal peripherals.
</p>
            </div>
          </div>

          <!-- 10 -->
          <a class="section-link" href="#" data-dd="transceiver">Transceiver</a>
          <div class="drop-panel" id="dd-transceiver" hidden aria-hidden="true">
            <div class="drop-inner">
              <img src="assets/photos/fm/transceiver.png" alt="Transceiver schematic">
              <p>The FM transceiver block handles all wireless transmission and reception as well as audio signal interfacing for the device. The SI4720 integrates modulation, demodulation, and RF signal processing into a single IC, reducing external component count and RF design complexity. An external antenna and matching inductor form the RF front end for efficient transmission and reception. Digital control and data exchange with the microcontroller are handled through a serial interface, allowing dynamic configuration of frequency, mode, and power. Audio input from the microphone is AC-coupled into the transceiver, while received audio is routed out for amplification. In the overall project, this block serves as the core communication engine that enables two-way FM voice operation.
</p>
            </div>
          </div>

          <!-- 11 -->
          <a class="section-link" href="#" data-dd="crystal-oscillator">Crystal oscillator</a>
          <div class="drop-panel" id="dd-crystal-oscillator" hidden aria-hidden="true">
            <div class="drop-inner">
              <img src="assets/photos/fm/crystal-oscillator.png" alt="Crystal oscillator schematic">
              <p>The crystal oscillator provides a stable and accurate reference clock for the transceiver’s internal timing and frequency synthesis. A 32.768 kHz crystal is used with matched load capacitors to ensure reliable oscillation and long-term frequency stability. This low-frequency reference supports precise tuning and consistent RF performance. Proper grounding and symmetric loading minimize phase noise and startup issues. In the broader system, this clock source underpins accurate modulation, demodulation, and channel stability.
</p>
            </div>
          </div>

          <!-- 12 -->
          <a class="section-link" href="#" data-dd="audio-amplifier">Audio amplifier</a>
          <div class="drop-panel" id="dd-audio-amplifier" hidden aria-hidden="true">
            <div class="drop-inner">
              <img src="assets/photos/fm/audio-amplifier.png" alt="Audio amplifier schematic">
              <p>The audio amplifier stage boosts the received audio signal to a level suitable for driving the speaker. The TPA321 is configured in a bridge-tied load arrangement to maximize output power while operating from a low supply voltage. AC coupling and biasing components condition the input signal and remove DC offsets. Local decoupling ensures stable operation under dynamic audio loads. The shutdown control allows the amplifier to be disabled when audio output is not required, reducing power consumption. In the overall system, this block converts demodulated RF audio into audible sound for the user.
</p>
            </div>
          </div>
        </div>
      </div>
    </div>


    <script>
      // ----- main Software behavior (reuses existing helpers) -----
const softwareLink  = document.getElementById("softwareLink");
const softwarePanel = document.getElementById("softwarePanel");

let softwareOpen = false;
let softwareSliding = false;

async function softwareSlideToCenter(){
  if (softwareSliding) return;
  softwareSliding = true;

  softwareLink.style.transform = "translateX(0px)";
  softwareLink.getBoundingClientRect();

  requestAnimationFrame(() => {
    const shift = shiftToViewportCenter(softwareLink);
    softwareLink.style.transform = `translateX(${shift}px)`;
  });

  await waitForTransition(softwareLink, "transform");
  softwareSliding = false;
}

async function softwareSlideBackLeft(){
  if (softwareSliding) return;
  softwareSliding = true;

  softwareLink.style.transform = "translateX(0px)";
  await waitForTransition(softwareLink, "transform");

  softwareSliding = false;
}

softwareLink.addEventListener("click", async (e) => {
  e.preventDefault();
  if (softwareSliding) return;

  softwareOpen = !softwareOpen;

  if (softwareOpen) {
    softwareLink.classList.add("is-selected");
    await softwareSlideToCenter();
    await openPanel(softwarePanel);
  } else {
    // close any open sub-panels inside software before closing
    softwarePanel.querySelectorAll(".drop-panel").forEach((p) => {
      p.classList.remove("is-open");
      p.style.maxHeight = "0px";
      p.hidden = true;
      p.setAttribute("aria-hidden", "true");
    });
    softwarePanel.querySelectorAll(".section-link").forEach((a) => a.classList.remove("is-selected"));

    await closePanel(softwarePanel);
    softwareLink.classList.remove("is-selected");
    await softwareSlideBackLeft();
  }
});

// keep centered on resize
window.addEventListener("resize", () => {
  if (!softwareOpen) return;

  const shift = shiftToViewportCenter(softwareLink);
  softwareLink.style.transform = `translateX(${shift}px)`;

  if (!softwarePanel.hidden && softwarePanel.style.maxHeight !== "none") {
    softwarePanel.style.maxHeight = softwarePanel.scrollHeight + "px";
  }
});

// ----- sub dropdown behavior for Software (separate selector) -----
document.querySelectorAll("[data-sw]").forEach((btn) => {
  const key = btn.getAttribute("data-sw");
  const panel = document.getElementById(`sw-${key}`);

  btn.addEventListener("click", async (e) => {
    e.preventDefault();
    if (softwarePanel.hidden) return;

    if (panel.hidden) {
      btn.classList.add("is-selected");
      await openPanel(panel);
    } else {
      await closePanel(panel);
      btn.classList.remove("is-selected");
    }
  });
});

      // ----- helpers -----
      function shiftToViewportCenter(el){
        const r = el.getBoundingClientRect();
        const elCenter = r.left + r.width / 2;
        const viewportCenter = window.innerWidth / 2;
        return viewportCenter - elCenter;
      }

      function waitForTransition(el, prop){
        return new Promise((resolve) => {
          const onEnd = (e) => {
            if (e.propertyName !== prop) return;
            el.removeEventListener("transitionend", onEnd);
            resolve();
          };
          el.addEventListener("transitionend", onEnd);
        });
      }

      async function openPanel(panel){
        panel.hidden = false;
        panel.setAttribute("aria-hidden", "false");

        panel.style.maxHeight = "0px";
        panel.getBoundingClientRect();

        panel.classList.add("is-open");
        panel.style.maxHeight = panel.scrollHeight + "px";

        await waitForTransition(panel, "max-height");
        panel.style.maxHeight = "none";
      }

      async function closePanel(panel){
        panel.style.maxHeight = panel.scrollHeight + "px";
        panel.getBoundingClientRect();

        panel.classList.remove("is-open");
        panel.style.maxHeight = "0px";

        await waitForTransition(panel, "max-height");

        panel.hidden = true;
        panel.setAttribute("aria-hidden", "true");
      }

      // ----- main Schematics behavior -----
      const schematicsLink = document.getElementById("schematicsLink");
      const schematicsPanel = document.getElementById("schematicsPanel");

      let schematicsOpen = false;
      let sliding = false;

      async function slideToCenter(){
        if (sliding) return;
        sliding = true;

        schematicsLink.style.transform = "translateX(0px)";
        schematicsLink.getBoundingClientRect();

        requestAnimationFrame(() => {
          const shift = shiftToViewportCenter(schematicsLink);
          schematicsLink.style.transform = `translateX(${shift}px)`;
        });

        await waitForTransition(schematicsLink, "transform");
        sliding = false;
      }

      async function slideBackLeft(){
        if (sliding) return;
        sliding = true;

        schematicsLink.style.transform = "translateX(0px)";
        await waitForTransition(schematicsLink, "transform");

        sliding = false;
      }

      schematicsLink.addEventListener("click", async (e) => {
        e.preventDefault();
        if (sliding) return;

        schematicsOpen = !schematicsOpen;

        if (schematicsOpen) {
          schematicsLink.classList.add("is-selected");
          await slideToCenter();
          await openPanel(schematicsPanel);
        } else {
          // close any open sub-panels instantly before closing main
          document.querySelectorAll(".schematics-list .drop-panel").forEach((p) => {
            p.classList.remove("is-open");
            p.style.maxHeight = "0px";
            p.hidden = true;
            p.setAttribute("aria-hidden", "true");
          });
          document.querySelectorAll(".schematics-list .section-link").forEach((a) => {
            a.classList.remove("is-selected");
          });

          await closePanel(schematicsPanel);
          schematicsLink.classList.remove("is-selected");
          await slideBackLeft();
        }
      });

      window.addEventListener("resize", () => {
        if (!schematicsOpen) return;

        const shift = shiftToViewportCenter(schematicsLink);
        schematicsLink.style.transform = `translateX(${shift}px)`;

        if (!schematicsPanel.hidden && schematicsPanel.style.maxHeight !== "none") {
          schematicsPanel.style.maxHeight = schematicsPanel.scrollHeight + "px";
        }
      });

      // ----- sub dropdown behavior -----
      document.querySelectorAll(".schematics-list [data-dd]").forEach((btn) => {
        const key = btn.getAttribute("data-dd");
        const panel = document.getElementById(`dd-${key}`);

        btn.addEventListener("click", async (e) => {
          e.preventDefault();
          if (schematicsPanel.hidden) return;

          if (panel.hidden) {
            btn.classList.add("is-selected");
            await openPanel(panel);
          } else {
            await closePanel(panel);
            btn.classList.remove("is-selected");
          }
        });
      });
      //extra
      
  // If you already have waitForTransition/openPanel/closePanel helpers on the page,
  // delete these three functions and keep only the click handler section.

  function waitForTransition(el, prop){
    return new Promise((resolve) => {
      const onEnd = (e) => {
        if (e.propertyName !== prop) return;
        el.removeEventListener("transitionend", onEnd);
        resolve();
      };
      el.addEventListener("transitionend", onEnd);
    });
  }

  async function openPanel(panel){
    panel.hidden = false;
    panel.setAttribute("aria-hidden", "false");

    panel.style.maxHeight = "0px";
    panel.getBoundingClientRect();

    panel.classList.add("is-open");
    panel.style.maxHeight = panel.scrollHeight + "px";

    await waitForTransition(panel, "max-height");
    panel.style.maxHeight = "none";
  }

  async function closePanel(panel){
    panel.style.maxHeight = panel.scrollHeight + "px";
    panel.getBoundingClientRect();

    panel.classList.remove("is-open");
    panel.style.maxHeight = "0px";

    await waitForTransition(panel, "max-height");

    panel.hidden = true;
    panel.setAttribute("aria-hidden", "true");
  }

  const regions = Array.from(document.querySelectorAll(".map-overlay .hot"));
  const panels = new Map(
    Array.from(document.querySelectorAll(".map-panels .drop-panel"))
      .map(p => [p.id.replace("panel-",""), p])
  );

  let active = null;

  regions.forEach(r => {
    r.addEventListener("click", async () => {
      const key = r.dataset.target;
      const panel = panels.get(key);
      if (!panel) return;

      // toggle close if same region clicked
      if (active === key){
        r.classList.remove("is-active");
        await closePanel(panel);
        active = null;
        return;
      }

      // close current
      if (active){
        const prevRegion = regions.find(x => x.dataset.target === active);
        const prevPanel = panels.get(active);
        if (prevRegion) prevRegion.classList.remove("is-active");
        if (prevPanel && !prevPanel.hidden) await closePanel(prevPanel);
      }

      // open new
      regions.forEach(x => x.classList.toggle("is-active", x.dataset.target === key));
      await openPanel(panel);
      active = key;

      // optional scroll
      panel.scrollIntoView({ behavior: "smooth", block: "start" });
    });
  });
      //END EXTRA
      //ZOOM
      (function setupMagnifier(){
    const wraps = document.querySelectorAll(".zoom-wrap");
    wraps.forEach((wrap) => {
      const img  = wrap.querySelector(".zoom-img");
      const lens = wrap.querySelector(".zoom-lens");
      if (!img || !lens) return;

      const zoom = Number(wrap.dataset.zoom || 2.2);     // magnification
      const lensSize = Number(wrap.dataset.lens || 220); // px

      lens.style.width = lensSize + "px";
      lens.style.height = lensSize + "px";

      function updateBackground(){
        lens.style.backgroundImage = `url("${img.currentSrc || img.src}")`;
      }

      function clamp(v, min, max){ return Math.max(min, Math.min(max, v)); }

      function move(e){
        const rect = img.getBoundingClientRect();

        // cursor position within the displayed image
        const x = e.clientX - rect.left;
        const y = e.clientY - rect.top;

        // keep lens inside image bounds
        const half = lensSize / 2;
        const lx = clamp(x, half, rect.width  - half);
        const ly = clamp(y, half, rect.height - half);

        // position lens
        lens.style.left = (lx - half) + "px";
        lens.style.top  = (ly - half) + "px";

        // compute background sizing/position relative to NATURAL image size
        const natW = img.naturalWidth  || rect.width;
        const natH = img.naturalHeight || rect.height;

        // scale ratio from displayed size to natural pixels
        const rx = natW / rect.width;
        const ry = natH / rect.height;

        const bgW = natW * zoom;
        const bgH = natH * zoom;

        // background position (centered on cursor)
        const bgX = -((lx * rx * zoom) - half);
        const bgY = -((ly * ry * zoom) - half);

        lens.style.backgroundSize = `${bgW}px ${bgH}px`;
        lens.style.backgroundPosition = `${bgX}px ${bgY}px`;
      }

      function on(){
        updateBackground();
        wrap.classList.add("is-on");
      }
      function off(){
        wrap.classList.remove("is-on");
      }

      // refresh if image loads later
      if (!img.complete) img.addEventListener("load", updateBackground, { once: true });

      wrap.addEventListener("mouseenter", on);
      wrap.addEventListener("mouseleave", off);
      wrap.addEventListener("mousemove", move);
      wrap.addEventListener("touchstart", (e) => { on(); move(e.touches[0]); }, { passive: true });
      wrap.addEventListener("touchmove",  (e) => { move(e.touches[0]); }, { passive: true });
      wrap.addEventListener("touchend", off);
    });
  })();
    </script>
  </div>
</body>
</html>
